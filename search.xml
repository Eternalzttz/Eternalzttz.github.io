<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[北航算法第三次练习赛-零崎的补番计划Ⅱ]]></title>
    <url>%2FBUAAclass3-1.html</url>
    <content type="text"><![CDATA[致敬DP 解题思路这一题就是一道裸的01背包问题，直接套用01背包模版即可。01背包是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。如果我们用子问题来定义状态：即f[i,j]表示前i件物品恰好放入一个容量为j的背包可以获得的最大价值。那么它的状态转移方程便是： 1f[i,j] = max(f[i-1,j],f[i-1,j-w[i]]+ v[i]); 这个状态转移方程是最基本的背包转移方程。它所表达的意思便是： 我们要求把i个物品放到容量为j的背包中这个问题，如果只考虑第i件物品（要么放，要么不放），那么就可以转化为一个只和前i-1件物品相关的问题。如果不放第i件物品，那么问题就变成了“前i-1件物品放入容量为j的背包中”，价值为F[i-1][j];如果放第i件物品，那么问题就转化为“前i-1件物品放入容量为j-w[i]的背包中”，此时得到的最大价值就是F[i-1,j-w[i]],再加上通过放入第i件物品获得的价值v[i]. 核心代码如下：123456 for (int i = 1; i &lt;= k; i++){ for (int j = 1; j &lt;= w[i] -1 ; j++) f[i][j] =f[i-1][j]; for (int j = w[i];j &lt;= t; j++) f[i][j] =max(f[i-1][j],f[i-1][j-w[i]]+v[i]);} 时间复杂度为 空间优化：通过观察我们可以发现，求解第i个子问题，它只和第 i-1个子问题有关，和之前的问题没有直接的关系，那么，毫无疑问，使用二维数组我们会浪费很多的空间。在这里，我们可以使用滚动数组将二维转化为一维数组求解。 注意这时候我们需要逆序循环第二维。 为什么呢？我们想想f[]数组的意义：在某个i下，f[j]表示的是当前背包容量为j时的最大值，所以在我们开始循环i时，由于还未开始循环，此时f[i]保存的是前一次 i -1 时背包的价值，即此时f[j]对应于f[i-1][j]],那么很明显：我们求解时：f[j] = max(f[j],f[j-w[i]]+v[i]);对应的就是：f[i][j] =max(f[i-1][j],f[i-1][j-w[i]]+v[i]); 核心代码为： 12345 for (int i = 0;i&lt;k;i++){ for (int j = t;j&gt;=w[i];j--){ f[j] = max(f[j],f[j-w[i]]+v[i]); }} 时间复杂度为 AC代码12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int f[310][20010],w[500],v[500];int main(){ int t,k; while(~scanf("%d%d",&amp;t,&amp;k)){ memset(f,0,sizeof(f)); memset(w,0,sizeof(w)); memset(v,0,sizeof(v)); for (int i = 1; i &lt;= k; i++) scanf("%d %d",&amp;v[i],&amp;w[i]); for (int i = 1; i &lt;= k; i++){ for (int j = 1; j &lt;= w[i] -1 ; j++) f[i][j] =f[i-1][j]; for (int j = w[i];j &lt;= t; j++) f[i][j] =max(f[i-1][j],f[i-1][j-w[i]]+v[i]); } printf("%d\n",f[k][t]); }} 空间优化：12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 20010;int v[N],w[N],f[N];int main(){ int t,k; while(~scanf("%d %d",&amp;t,&amp;k)){ memset(v, 0, sizeof(v)); memset(w, 0, sizeof(w)); memset(f, 0, sizeof(f)); for (int i = 0;i&lt;k;i++) scanf("%d %d",&amp;v[i],&amp;w[i]); for (int i = 0;i&lt;k;i++){ for (int j = t;j&gt;=w[i];j--){ f[j] = max(f[j],f[j-w[i]]+v[i]); } } printf("%d\n",f[t]); }}]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>算法上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北航算法第二次上机题解]]></title>
    <url>%2FBUAAtest2.html</url>
    <content type="text"><![CDATA[北航第二次算法上机，就分数和排名而言，自己还算是不错的。然而，对于自己的上机，其实自己是不满意的，出现了不该出现的错误以及没写出来本可写出来的题。在这里写下题解，希望下次上机DP能以此为戒，冷静处理。 A: ModricWang’s Real QuickSort Query解题思路这是一道考察快排的题，题目的意思对照案例看一下，也表述的很清楚了。事实上，按照题目给出的提示一步一步写，基本上核心代码就齐了，剩下的就是需要自己判断和输出做一些调整，然而我还是没过 我们来看看如何按照提示写代码：12for (int i = 0;i&lt;n;i++) scanf("%d",&amp;a[i]);//设数组为arr[n] ，元素从0开始存储 1234567891011int mid = (right+left+1)/2; int key = a[mid];//令i=0，j=n−1,mid=arr[n/2],这里我传入的是left和right。 int i = left, j = right; while(i&lt;=j){//如果i≤j，转到4，否则转到步骤7 while(a[i]&lt;key) i++; //如果arr[i]&lt;mid,i++ ，重复执行直到arr[i]≥mid while(a[j]&gt;key) j--; //如果arr[j]&gt;mid,j−− ，重复执行直到arr[j]≤mid if(i&lt;=j){ //如果i≤j, 交换arr[i] 和arr[j]，i++,j−− , 转到步骤4 swap(a[i], a[j]); i++;j--; } } 1quicksort(left, i-1);//数组被分为左右两个部分：[0,i)和[i,n) 我们要左边部分，所以选择left到i-1 好了，事实上，需要自己写的代码也就10行左右，我们所需要做的便是在函数递归的时候，留下一个计数器，一旦达到两次，我们就可以从标志元素开始进行输出 另外，在函数结束的时候，我们可以使用exit(0);表示直接退出程序，因为如果仅仅是return的话，只会返回上一次递归的过程，而非退出整个递归函数。 AC 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define N 1000010int a[N];int num = 0,n;void quicksort(int left, int right){ num ++; if(left&gt;=right) return; int mid = (right+left+1)/2; int key = a[mid]; int i = left, j = right; while(i&lt;=j){ while(a[i]&lt;key) i++; while(a[j]&gt;key) j--; if(i&lt;=j){ swap(a[i], a[j]); i++;j--; } } //这是答案输出部分，我们可以看到，每一次划分是[0,i),[i,n),我们需要输出的是后面的一部分，所以，我们直接输出到right就行，输出后直接退出程序。 if(num == 2){ for (;i&lt;=right;i++) printf("%d ",a[i]); exit(0); } quicksort(left, i-1);}int main(){ scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++) scanf("%d",&amp;a[i]);//设数组为arr[n] ，元素从0开始存储 quicksort(0, n-1);} B: 女娲加农炮解题思路考点： 优先队列 这一题需要我们求出所需的最小能量值。 对于合并的这个过程，我们可以思考一下:每一次的过程为取两个原子聚合成一个原子，显然，对于有n 个原子，我们需要聚和n-1次（每一次聚合总原子数减少一个，我们需要最后只剩下一个原子） 这个过程已经是确定的了，接下来我们想想如何得到最小值：因为过程确定，那么无论采用何种决策方案， 次合并后都将只剩下一个原子。若是想得到最小的答案，那么我们只要每次均取最小的两个合并即可。 正确性显然。其实也不一定显然，然而并不会证类似于贪心的思想，我们可以得到下列的解题步骤： 对所有数排序，得到一个有序数组，选择数组最小的两个数合并。ans += a1+a2 将合并后的原子插入到原有序数组中，保持新数组依旧有序。 重复1-2过程，直到整个数组中只有一个元素 所以，用到的数据结构即为优先队列,注意STL中优先队列默认是从大到小排列的，需要使用cmp函数，或者greater ，让其从小到大排列 关于优先队列的使用，可以看看这篇blog 时间复杂度：优先队列的插入删除操作时间复杂度为 ,整个过程需要执行 次，所以总的时间复杂度为 AC代码12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;int main(){ int n; while(~scanf("%d",&amp;n)){ ll a,b,c,sum=0 ; priority_queue&lt;ll,vector &lt;ll&gt;,greater&lt;ll&gt;&gt; q; for (int i =0 ;i&lt;n;i++){ scanf("%lld",&amp;a); q.push(a); } while(q.size()&gt;1){ b = q.top();q.pop(); c = q.top();q.pop(); sum += (b+c); q.push(b+c); } printf("%lld\n",sum); }} C: 第k顺序统计量解题思路本题是为了求第k小的数。首先我们可以想到直接排序求解，所有的数排序有可以直接求出第k小的数。这么思考当然是没错的，然而即便是调用sort函数，时间复杂度也为 ,对于这一题而言，时间复杂度过高，会无情的TLE 为什么排序不行呢？因为在这个过程中我们运行了很多不必要的过程，比如我们只需要第k小的数，不对其它数做要求，那么我们花费在排其它数据的时间就属于无用功。 要想快，那么我们首先想到的应该就是分治，事实上绝大多数加快程序运行的方法都是使用分治算法。学习了快速排序，我们可以想到，每一次快速排序都会有一个分隔元素，记为key。每一次快排后，key都在最终排序的正确位置，前半部分都比key小，后半部分都比key大。那么我们只要比较key的位置和k的大小，便可以判断出下一步是在前半部分还是后半部分进行，从而减小了计算量。 时间复杂度为 AC代码1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int quicksort(int a[],int left,int right,int num){ int key = a[left]; int i = left,j = right; while(i&lt;j){ while(i&lt;j&amp;&amp;a[j]&gt;=key) j--; a[i] = a[j]; while(i&lt;j&amp;&amp;a[i]&lt;=key) i++; a[j] = a[i]; } a[i] = key; if(num == i)//找到结果，返回 return a[i]; else if(num&lt;i) return quicksort(a, left, i-1,num);//递归查找前半部分 else return quicksort(a, i+1, right,num);//递归查找后半部分}int a[3000005];int main() { int n; int A,B,C,k; while(~scanf("%d %d %d %d %d",&amp;A,&amp;B,&amp;C,&amp;a[1],&amp;k)){ for(int i = 2; i &lt;= 3000000; ++i) a[i] = ((1LL * a[i - 1] * A ^ B) + C) % 1000000007; int ans = quicksort(a, 1,3000000 ,k); printf("%d\n",ans); }} 事实上，可以直接调用stl函数，也能解决掉这一题：1234567891011121314#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int N = 3000010;int a[N], A, B, C, k;int main() { for(int tc = 0; tc &lt; 7; ++tc) { scanf("%d%d%d%d%d", &amp;A, &amp;B, &amp;C, &amp;a[1], &amp;k); for(int i = 2; i &lt;= 3000000; ++i) a[i] = ((1LL * a[i - 1] * A ^ B) + C) % 1000000007; std::nth_element(a + 1, a + k, a + 3000001); printf("%d\n", a[k]); } return 0;} 菜的真实，完全不知道还有这个函数emmm D: 天秤的烦恼解题思路这道题主要就是考排序和去重。 其实题目意思感觉还是有那么一点点歧义的，因为它描述的是在所有晶体管中为第几大，那么要不要去重也不好说。不过WA后也可以试着换换思路，万一对了呢 因为考的是排序+去重，代码的实现方法就可以有很多种，可以选择直接调用库函数，也可以自己写一个判断，也并不需要几行代码～～～ 在这里，我们先用sort函数排序，然后用一个临时的数组，如果a[i]!=a[i-1],那么把这个a[i]赋值给b[num++],最后遍历一遍就可以得出结果 注意如果是使用cin 和cout 的话需要取消流同步，不然会造成TLE 时间复杂度为 AC代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define N 1000010long long a[N],b[N];int main(){ long long n,k; while(~scanf("%lld",&amp;n)){ for (int i = 0;i&lt;n;i++){ scanf("%lld",&amp;a[i]); } scanf("%lld",&amp;k); sort(a, a+n); b[0] = a[0]; int num = 1; for (int i = 1;i&lt;n;i++){ if(a[i] == a[i-1]) continue; else b[num++] = a[i]; } for (int i = num-1;i&gt;=0;i--){ if(b[i] == k){ printf("%d\n",num-i); break; } } }} E: 图书整理解题思路主要考点是查找方法，对于这道题，可以有很多不同的做法： 方法1:计数 首先我们可以看看数据的范围：1≤n,t≤100,000 ，number在int范围内。 数据范围不大，只有1e5的大小，所以我们可以对每本书直接计数，使用两个数组a[N],b[N],其中a[i]代表编号为i本的书的数量，b[i]代表第i次查询的编号，对于每次查询，输出一遍即可。时间复杂度为 。 方法2:二分查找上下界法1只适合于数据较小的情况，如果数据的范围为int内，计数数组是开不了那么大的，那么法1就不适用了，事实上，助教的本意也不是让我们用计数水过去，而是考察二分查找上下界。 只要把常规的二分改一改即可：如查找下界：最后得到的lower是最后一个小于p的位置。上界修改一处即可，具体可看法二代码，得到的是最后一个大于等于p的位置。注意数组存储位置为1-n;12345678910int left = 0, right = n+1; int mid = (left + right) / 2; while (right - left &gt; 1){ if (book[mid] &lt; p) left = mid; else if (book[mid] &gt;= p) right = mid; mid = (left+right)/2; } lower = mid; 方法3：map使用stl中的map，当然，这个的思想和法一其实是一样的，不过使用stl相对而言更易写代码。 方法4：双指针移动这个方法其实我还没弄懂，暂且放一份AC代码吧 真实菜鸡 AC代码 方法一：计数1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define N 100010int a[N],b[N];int main(){ int n,t; while(~scanf("%d %d",&amp;n,&amp;t)){ memset(a,0,sizeof(a)); memset(b, 0, sizeof(b)); int num; for (int i = 0;i&lt;n;i++){ scanf("%d",&amp;num); a[num]++; } for (int i = 0;i&lt;t;i++) scanf("%d",&amp;b[i]); for (int i = 0;i&lt;t;i++) printf("%d ",a[b[i]]); printf("\n"); }} 方法二：二分12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int book[N],n,t,p,lower,higher;int main(){ while(~scanf("%d %d",&amp;n,&amp;t)){ for (int i = 1;i&lt;=n;i++) scanf("%d",&amp;book[i]); sort(book,book+n+1); for (int i = 0; i &lt; t; i++){ scanf("%d", &amp;p); int left = 0, right = n+1; int mid = (left + right) / 2; while (right - left &gt; 1){ if (book[mid] &lt; p) left = mid; else if (book[mid] &gt;= p) right = mid; mid = (left+right)/2; } lower = mid; left = 0, right = n+1; mid = (left + right) / 2; while (right - left &gt; 1){ if (book[mid] &lt;= p) left = mid; else if (book[mid] &gt; p) right = mid; mid = (left+right)/2; } higher = mid; printf("%d ",higher - lower); } printf("\n"); }} 方法三：map1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int n, t, book, p;map&lt;int, int&gt; mp;int main(){ while (scanf("%d%d", &amp;n, &amp;t) != EOF){ mp.clear(); for (int i = 0; i &lt; n; i++){ scanf("%d", &amp;book); mp[book]++; } for (int i = 0; i &lt; t; i++){ scanf("%d", &amp;p); printf("%d ", mp[p]); } printf("\n"); }} 方法四：双指针移动123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt;int aa,bb;char ch;int F(){ while(ch=getchar(),(ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-'); ch=='-' ? aa=bb=0 : (aa=ch-'0',bb=1); while(ch=getchar(),ch&gt;='0'&amp;&amp;ch&lt;='9')aa=aa*10+ch-'0'; return bb ? aa : -aa;}const int N = 100010;struct lr { int x, i; bool operator &lt;(const lr &amp;a)const { return x &lt; a.x; }} Q[N];int n, q, a[N], ans[N];using std::sort;int main() { while(~scanf("%d%d", &amp;n, &amp;q)) { for(int i = 0; i &lt; n; ++i) a[i] = F(); sort(a, a + n); for(int i = 0; i &lt; q; ++i) Q[i].i = i, Q[i].x = F(); sort(Q, Q + q); int j = 0; for(int i = 0; i &lt; q; ++i) { if(i &amp;&amp; Q[i].x == Q[i - 1].x) { ans[Q[i].i] = ans[Q[i - 1].i]; continue; } int k = j; while(j &lt; n &amp;&amp; a[j] == Q[i].x) ++j; ans[Q[i].i] = j - k; } for(int i = 0; i &lt; q; ++i) printf("%d%c", ans[i], " \n"[i == q-1]); } return 0;} F: 女娲加农炮||解题思路这一题可以说和前面B题相似度90%，我们只需要改一改判断条件，每一push的为取前三个的值即可。 判断条件改为q.size()&gt;2,即剩三个及以上时我们再取。 AC代码12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;queue&gt;typedef long long ll;using namespace std;priority_queue&lt;ll,vector &lt;ll&gt;,greater&lt;ll&gt;&gt; q;int main(){ int n; while(~scanf("%d",&amp;n)){ ll a,b,c,d,sum=0 ; for (int i =0 ;i&lt;n;i++){ scanf("%lld",&amp;a); q.push(a); } while(q.size()&gt;2){ b = q.top();q.pop(); c = q.top();q.pop(); d = q.top();q.pop(); sum+= (b+c+d); q.push(b+c+d); } printf("%lld\n",sum); while(!q.empty()) q.pop(); }} G: 数组优美和值解题思路这道题几乎和上一次的上机题序列优美差值一模一样，使用前缀和+归并排序，助教对于这道题已经有所提示。 要注意的点是数组首位补零，即a[0] = 0;排序的时候记住是0-n，而非1-n。 我们来看一看这道题： 且 显然，如果令 ; 那么 那么这道题就相当于求 且 的值这时候便和上一次上机的题目一模一样了。时间复杂度为 ##AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;typedef long long ll;const int N = 1000010;ll a[N],k[N];int n,L,R;ll ans = 0;void merge(int left,int right){ if(left&gt;=right) return; int mid = (left+right)/2; merge(left, mid); merge(mid+1, right); int s = left,e = left; for (int i = mid+1;i&lt;=right;i++){ while(a[i]-a[e]&gt;=L&amp;&amp;e&lt;=mid) e++; while(a[i]-a[s]&gt;R&amp;&amp;s&lt;=mid) s++; ans +=e-s; } int i = left,j = mid+1,p=left; while(i&lt;=mid&amp;&amp;j&lt;=right){ if(a[i]&lt;=a[j]) k[p++] = a[i++]; else k[p++] = a[j++]; } while(i&lt;=mid) k[p++] = a[i++]; while(j&lt;=right) k[p++] = a[j++]; for (int i = left;i&lt;=right;i++) a[i] = k[i];}int main(){ int T; scanf("%d",&amp;T); for (int i = 0;i&lt;T;i++){ ans = 0; long long num; a[0] = 0; scanf("%d%d%d",&amp;n,&amp;L,&amp;R); for (int j = 1;j&lt;=n;j++){ scanf("%lld",&amp;num); a[j] = a[j-1]+num; } merge(0, n); printf("%lld\n",ans); } return 0;} 事实上，使用前缀和的时候我们可以发现，初始数组实际上是有序的，所以，我们其实不用分治法，这一题也可以得出答案,并且效率更高： AC代码21234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;typedef long long ll;const int N = 1000010;ll a[N];int T,n,l,r,num;int main() { scanf("%d",&amp;T); for (int i = 0; i &lt; T; i++) { ll ans,rp,lp; memset(a, 0, sizeof(a)); a[0] = 0; scanf("%d %d %d", &amp;n, &amp;l, &amp;r); for (int j = 1; j &lt;= n; j++){ scanf("%d", &amp;num); a[j] = a[j-1] + num; } ans = 0; rp = 0; lp = 1; for (int j = 1; j &lt;= n; j++){ while(lp &lt;= n &amp;&amp; a[lp] - a[j-1] &lt; l || lp &lt; j) lp ++; while(rp &lt; n &amp;&amp; a[rp+1] - a[j-1] &lt;= r) rp ++; if(lp &lt;= rp) ans += rp - lp + 1; } printf("%lld\n",ans); }} H: W型串解题思路我们可以看看关于w型串的定义，很明显，这是一个递归定义，那么我们便可以对这道题递归求解。 首先，我们来看看非w型串的特点： 括号不匹配，那么一定不是w型串 如果记flag为分隔位，那么只能有一个分隔位，即()()形式，如果分隔位大于1，那么一定不是w型串 如果满足上面两条，那么我们应该递归判断里面内容，最后即可得到答案； 我们来看看check函数：12345678910111213141516int check(int left,int right){ //判断从left到right是不是w型串 if(left == right) return 1; //如果为空串，复合条件 int cnt = 0,flag = 0; //cnt判断括号匹配，flag记录分隔位 for (int i = left;i&lt;right;i++){ if(str[i] == '(') cnt++; else cnt--; if(cnt&lt;0) return 0 ;//括号不匹配 if(cnt == 0&amp;&amp;i+1!=right){ if(flag == 0 ) flag = i+1;//记下分隔位 else return 0 ;//分隔位多于1，不是w型串 } } if(cnt!=0) return 0;//括号不匹配 else if(flag == 0) return check(left+1, right-1);//没有分隔位，递归查找 else return check(left+1,flag - 1)&amp;&amp;check(flag+1, right-1);//有分隔位，递归查找两边} 时间复杂度为 AC代码12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 1010char str[N];int check(int left,int right){ if(left == right) return 1; int cnt = 0,flag = 0; for (int i = left;i&lt;right;i++){ if(str[i] == '(') cnt++; else cnt--; if(cnt&lt;0) return 0 ; if(cnt == 0&amp;&amp;i+1!=right){ if(flag == 0 ) flag = i+1; else return 0 ; } } if(cnt!=0) return 0; else if(flag == 0) return check(left+1, right-1); else return check(left+1,flag - 1)&amp;&amp;check(flag+1, right-1);}int main(){ int n,len,ans = 0; scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++){ scanf("%s",str); len = strlen(str); ans = check(0, len); if (ans == 1) printf("Yes\n"); else printf("No\n"); }} I: 堆积糖果解题思路这一题理解上可能有一定的困难，暂且放上助教版题解：考点：二维前缀和、数学、随机化、概率 预计现场完成人数：&lt;3这道题主要是给大家介绍一种思路，同时作为概率算法的一种介绍，大家有兴趣可以研究，没有兴趣可以不用着急，期末一定不会出这样的题。 题意是对一个矩阵的子矩阵进行染色，每个格子都有自己的接受颜色，问所有染过非自己接受颜色的格子数量。如果我们对每个颜色编号，每次染色就把对应格子加上这个颜色的编号，那么，一个格子没有被其他颜色染过的必要不充分条件是：这个格子被染色的颜色和是这个颜色的整数倍。那么，如果对一个颜色随机一个比较大的数，那么上述必要条件存在很大概率不会产生冲突（比如1+3=2+2这种，即把不同颜色累积的认为是该种颜色的累计），因为颜色的值是随机的，而且比较大。那么，如果对所有颜色进行多次随机，进行上述必要性判断，就能认为概率上每个存在非接受颜色染色的格子，都存在一组随机数，能够让这个格子的和不是他接受颜色对应的随机数的倍数。简单感性理解：假设一组随机数，求和出错概率为p，那么对于n组随机数都出错的概率是p^n，即使p是0.5，n取10的时候出错概率已经小于千分之一了。但是事实上，大随机数下，几个数的和是另一个数的倍数的概率已经很低，基本上一次就能确定是否由不属于他的颜色，这个概率大家可以尝试探索。用二维前缀和可以O(1)完成子区间添加一个数，和子区间求和。这个东西在后面会介绍一下过程，具体原理大家可以手动模拟理解一下。 特别地，如果不采用随机，其实对颜色1-n*m编号以后，分别记录i, i*i的前缀和，要求一个格子i的和、i*i的和分别是他接受颜色对应的值的编号x的倍数、x*x的倍数，也可以区分一个格子是否被不被接受的颜色所染色。 对于二维前缀和，如果对[[x1, y1], [x2, y2]]矩形整体加一个数v，可以在某个a数组[x1, y1]、[x2+1,y2+1]处+v, [x1, y2+1]、[x2+1,y1]处-v，然后对a数组求对应的前缀和：12sum[i][j] = sum[i - 1][j] + sum[i] [j - 1] + a[i][j];然后，某个格子[x, y]的值可以由sum[x][y] - sum[x][y-1]-sum[x-1][y]+sum[x-1][y-1]。 这也同样可以求某个子矩形的和值。 题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1000010;ll Map[N];vector&lt;ll&gt; cnt[N],a[N];int main(){ int n,m,t; scanf("%d %d %d",&amp;n,&amp;m,&amp;t); for (int i = 0; i &lt;= n+1; i++){ a[i].resize(m+2); cnt[i].resize(m+2); } srand(time(0)); for (int i = n * m; i &gt; 0; i--) Map[i] = (rand() * 1ll&lt;&lt;24ll)^(rand() &lt;&lt; 8ll)^(rand()%(1ll&lt;&lt;8)); for (int i = 1, v; i &lt;= n; i++){ for (int j = 1; j &lt;= m; j++){ scanf("%d",&amp;v); a[i][j] = Map[v]; } } while(t--){ int x1,y1,x2,y2,v; scanf("%d %d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;v); ++x2;++y2; ll w = Map[v]; cnt[x1][y1] += w; cnt[x1][y2] -= w; cnt[x2][y1] -= w; cnt[x2][y2] += w; } int ans = 0; for (int i = 1; i &lt;= n; i++){ for (int j = 1; j &lt;= m; j++){ cnt[i][j] += cnt[i-1][j] + cnt[i][j-1] - cnt[i-1][j-1]; ans += (cnt[i][j] % a[i][j])!=0; } } printf("%d\n",ans); return 0;}]]></content>
      <categories>
        <category>算法上机</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>算法上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盗梦空间]]></title>
    <url>%2FInception.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>心灵驿站</category>
        <category>影片</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>台词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STLqueue（2）]]></title>
    <url>%2FSTLqueue2.html</url>
    <content type="text"><![CDATA[在c++的queue头文件中，还定义了一个重要的数据结构，那就是优先队列priority_queue。 什么是优先队列？顾名思义，那就是队列中的每个元素都会对应一个优先级，具有最高优先级的会放到队首，率先访问。 标准库使用 ：优先队列的引用同普通队列一样：12#include &lt;queue&gt;using namespace std; 然后再声明需要使用的队列：12priority_queue&lt;int&gt; q; //代表优先队列里的元素类型为 intpriority_queue&lt;double&gt; q; //代表优先队列里的元素类型为 double queue库函数：在这个库中，主要实现了以下函数： push(): 该函数会将一个函数放入队列中 top(): 该函数会返回queue中的第一个元素，即队首元素 pop(): 该函数移除queue内的第一个元素（队首元素） size(): 该函数会返回queue内的元素个数 empty(): 该函数在队列为空时返回1，否则为0 swap(): 交换两个队列的值 注意：在使用优先队列的时候，没有front()函数和back()函数，访问优先队列队首时需要使用top()函数，这是和普通队列不同的地方，避免记错混用 优先队列特性使用优先队列的一个好处，那就是可以根据优先级自动排序。我们来看看这个程序：1234567891011121314#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int&gt; q; q.push(3);q.push(6); q.push(8);q.push(12); q.push(0); while(q.size()){ printf("%d ",q.top()); q.pop(); } return 0;} 程序的意思就是将3，6，8，12，0入队，我们可以看看输出：12 8 6 3 0很明显，输出的值已经按照从大到小的顺序排好了。默认情况下，优先队列会从大到小的排列元素。 使用less和greater对于优先队列的声明如下：12priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; p;priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 使用less 表示从大到小排列队中的元素；使用greater 表示从小到大的排列队中的元素。 使用结构体某些时候，我们不仅仅需要对某个单一元素使用优先队列，需要对整个结构体使用优先队列排序，当然，c++是支持这个操作的，我们所需要的，便是要去定义一个小于运算符： 结构体申明如下：12345678910#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct node{ int a; int b; bool operator &lt; (const node &amp;x) const{//重载小于符号 return b&lt;x.b; }}; 然后声明的时候使用：1priority_queue &lt;node&gt; q; 例题应用最近，Nova君遇到了一件非常棘手的问题。他需要整理非常多的解题报告。每份解题报告的题目数量是不定的。Nova君每次需要将两份报告的题目解析合成到一份里。假设两份报告的题解数分别为a和b，那么合成这两份报告消耗Nova君a+b的hp值。现在有n份报告，题解数分别为a0,a1,a2,,,an-1，请问Nova最少消耗多少hp？ 解题思路 很明显，如果我们需要消耗最少的hp，那么我们需要每次需要合成消耗最小hp的报告，合成后，我们需要将合成的新的一份报告按照新的所需消耗hp值插入到原顺序中，那么，优先队列正好可以帮我们实现这个过程。12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;queue&gt;typedef unsigned long long ull;using namespace std;int main(){ int n; while(~scanf("%d",&amp;n)){ ull a,b,c,sum=0 ; priority_queue&lt;ull,vector &lt;ull&gt;,greater&lt;ull&gt;&gt; q; for (int i =0 ;i&lt;n;i++){ scanf("%lld",&amp;a); q.push(a); } while(q.size()&gt;1){ b = q.top();q.pop(); c = q.top();q.pop(); sum+= (b+c); q.push(b+c); } printf("%lld\n",sum); }}]]></content>
      <categories>
        <category>STL</category>
        <category>queue</category>
      </categories>
      <tags>
        <tag>queue</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STLqueue（1）]]></title>
    <url>%2FSTLqueue1.html</url>
    <content type="text"><![CDATA[queue 是c++的一个标准库，这个标准库对队列进行了实现。 标准库使用 ：12#include &lt;queue&gt;using namespace std; 然后再声明需要使用的队列：123queue&lt;int&gt; q; //代表队列里的元素类型为 intqueue&lt;double&gt; q; //代表队列里的元素类型为 doublequeue&lt;string&gt; q; //代表队列里的元素类型为 string queue库函数：在这个库中，主要实现了以下函数： push(): 该函数会将一个函数放入队列中 front(): 该函数会返回queue中的第一个元素，即队首元素 back(): 该函数返回queue中的最后一个元素，即队尾元素 pop(): 该函数移除queue内的第一个元素（队首元素） size(): 该函数会返回queue内的元素个数 empty(): 该函数在队列为空时返回1，否则为0 swap(): 交换两个队列的值 注意，函数front()和back()本身只是访问队列中的元素，并不对该元素作出操作，所以，如果不执行pop()操作，多次访问的值是一样的，不会改变（因为队列并没有改变); 函数使用：示例：12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;queue&gt; //引入头文件using namespace std;int main(){ int n = 10; int a[n]; queue&lt;int&gt; q;//声明一个int型队列 queue&lt;int&gt; q2; for (int i = 0; i &lt; n; i++){ scanf("%d",&amp;a[i]); q.push(a[i]);//元素入队 // printf("%d\n",q.back());//访问队尾元素 } printf("%ld\n",q.size());//队列元素数目 while(!q.empty()){ printf("%d ",q.front());//访问队首元素 q.pop();//队首出队 } printf("\n"); q.push(1);q.push(2); q2.push(3);q2.push(4);q2.push(5); printf("%ld %ld\n",q.size(),q2.size()); swap(q, q2);//交换两个队列的元素 printf("%ld %ld\n",q.size(),q2.size());}]]></content>
      <categories>
        <category>STL</category>
        <category>queue</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北航算法第二次练习赛]]></title>
    <url>%2FBUAAclass.html</url>
    <content type="text"><![CDATA[算法练习记录系列，北航算法第二次练习赛。 A DH的字符串游戏解题思路这一题要求是判断字符串等价，然而给出的字符串等价的定义却有一点的坑。我们看一看他的要求： 若单个字符串长度为奇数，则两字符串只有完全相等才可称为等价 若单个字符串长度为偶数，则将a从中间分为长度相等的两半，记为a1和a2，将b从中间分为长度相等的两半，记为b1和b2，满足a1与b1等价且a2与b2等价，或者a1与b2等价且a2与b1等价，称a与b等价 毫无疑问，对于奇数字符串好求，直接依次判断一遍即可。 然而对于偶数字符串，我们可以看到，它需要前后两部分互判。对于这个过程，我们可以举一个简单例子思考一下： 如果是两个长度为8的字符串，那么首先我们要将其一分为二，判断前后长度为4是是否等价，对于长度为4的前后两部分，我们需要继续一分为二，判断为2时是否相等，长度为2时我们判断长度为1时前后是否相等··· ··· 由此我们可以看到，对于偶数的判断，本质上是一个递归的过程，所以我们可以写出以下代码： AC代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N = 200001;char a[N],b[N];int cmp(char a[],char b[],int num){ int flag = 0; if(num%2 == 1){ for (int i = 0;i&lt;num;i++){ if(a[i] != b[i]){ flag = 1; break; } } return flag; } else{ int x = num/2; char a1[x],a2[x],b1[x],b2[x]; for (int i =0 ;i&lt;x;i++){ a1[i] = a[i];a2[i] = a[i+x]; b1[i] = b[i];b2[i] = b[i+x]; } if((cmp(a1, b1,x)==0&amp;&amp;cmp(a2, b2,x)==0)||(cmp(a1, b2, x)==0&amp;&amp;cmp(a2, b1, x)==0)) flag = 0; else flag = 1; return flag ; }}int main(){ while(~scanf("%s",a)){ scanf("%s",b); int num = strlen(a); int ans = cmp(a, b, num); if(ans == 0) printf("YES\n"); else printf("NO\n"); }} B ModricWang的布线问题 II解题思路本质上这是一个求最小生成树的问题，只是有一个点需要特殊处理而已。 需要注意的是，ModricWang的计算机并不全都很强。他有一台计算机的承载能力有限，只能接入一根网线。 既然只能接入一根网线，那么，毫无疑问，应该接入的是与这个点相连的最短的那根网线，那么首先应该求出除该点外n-1个点所构成的最小生成树，最后加入这条边即可。 使用kruskal算法求解 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int u,v,w;}edge[600005];int fa[10001],n,m,ans,eu,ev,cnt,k;bool cmp(Edge a,Edge b){ return a.w&lt;b.w;}int find(int x){ while(x!=fa[x]) x=fa[x]=fa[fa[x]]; return x;}void kruskal(){ sort(edge,edge+m,cmp); for( int i=0;i&lt;m;i++){ if(edge[i].u == k||edge[i].v == k) continue; //如果这条边与K点相连，那么跳过 eu=find(edge[i].u); ev=find(edge[i].v); if(eu==ev) continue; ans+=edge[i].w; fa[ev]=eu; if(++cnt==n-2)//前n-1个点的最小生成树已找到 break; }}int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;k); int min = 999999999; for( int i=1;i&lt;=n;i++) fa[i]=i; for( int i=0;i&lt;m;i++){ scanf("%d %d %d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); if(edge[i].u == k||edge[i].v == k){ if(edge[i].w&lt;min){ min = edge[i].w; } } } kruskal(); ans+=min;//接入与k点相连的最小的边 printf("%d",ans); return 0;} C Mdd去旅游(II)解题思路深度优先遍历。以地点为点，线路为边，建立一个无向图，从任意顶点开始，对图进行深度优先遍历活着广度优先遍历，如果能够遍历到所有的顶点，那么就说明可以到所有的地点，反之说明到不了。 AC代码 （深度优先遍历图）12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;int e[101][101],vis[101];int k,m;int ans;void dfs(int x){ vis[x]=1; ans++; int i; for(i=0;i&lt;k;i++) if(e[x][i]&amp;&amp;!vis[i]) dfs(i);}int main(){ while(~scanf("%d %d",&amp;k,&amp;m)){ ans =0; memset(vis,0,sizeof(vis)); memset(e,0,sizeof(e)); for (int i =0 ;i&lt;m;i++){ int a,b; scanf("%d %d",&amp;a,&amp;b); e[a][b] = 1; e[b][a] = 1; } dfs(0); if(ans == k) printf("Yes\n"); else printf("No\n"); }} D ModricWang的局域网解题思路这一题同上一题一样，也是遍历整个图。从1～n依次判断，对于其中的某个顶点i，如果没有遍历过这个顶点，那么从这个顶点开始，再进行一次遍历，看到最后需要遍历多少次，那么这个结果就是答案。 深度优先遍历或者广度优先遍历都行。 AC代码 （深度优先）123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int N = 1001;int n,m,ans;int e[N][N],vis[N];void dfs(int x){ vis[x] = 1; for (int i = 1;i&lt;=n;i++){ if(!vis[i]&amp;&amp;e[x][i] == 1){ dfs(i); vis[i] = 1; } }}int main(){ scanf("%d %d",&amp;n,&amp;m); for (int i = 0;i&lt;m;i++){ int a,b; scanf("%d %d",&amp;a,&amp;b); e[a][b] = 1; e[b][a] = 1; } for (int i =1;i&lt;=n;i++){ if(!vis[i]){ dfs(i); ans++; } } printf("%d",ans); return 0;} E Mdd去旅游(III)解题思路这一题看着和第三题的题目非常的像，所有一上来我就是邻接表+深度优先搜索，结果，果不其然，因为时间复杂度过高，TLE了。经过上网找资料blog写题法 原来这题考的是并查集！ AC代码1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100001;int ver[N],ans[N];int n,m,u,v;int find(int a){ if(ver[a]!=a) ver[a] = find(ver[a]); return ver[a];}int main(){ memset(ans,0,sizeof(ans)); scanf("%d %d",&amp;n,&amp;m); for (int i = 0;i&lt;n;i++) ver[i] = i; for (int i = 0;i&lt;m;i++){ scanf("%d %d",&amp;u,&amp;v); int eu,ev; eu = find(u); ev = find(v); if(eu!=ev) ver[ev] = eu; } for(int i=0;i&lt;n;i++) ans[ver[i]]++; sort(ans,ans+n); printf("%d\n",ans[n-1]);} F DH去看球解题思路emmm 因为这题，成功达成两页WA成就 这题思路还是好想的，首先对路线建图，然后对每个顶点跑最短路算法，算出两两点之间的最短距离，然后根据出租车能走的最长距离和价格重新建立一个图，如果最长距离大于等于这个点到其他点的距离，说明这个点与其他点之间有一条边，边的权值为车费。最后以车费为权值再跑一遍最短路算法。求出起始点与终点之间的最小车费即可。 主要是数据太出锅了 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define M 1000005#define N 1005#define INF 1e13typedef long long ll;struct node { ll u,v,w,next;};ll dis[N][N];ll head[N],len[N],head2[N],len2[N];bool vis[N];ll n,m,cnt;void add(node edge[],ll u,ll v,ll w){ edge[cnt]={u,v,w,head[u]}; head[u] = cnt++;}ll first,tag;//for dijkstrall ddis[N];bool dvis[N];ll de[N][N];void dijkstra(){ for (int i = 1;i&lt;=n;i++){ ddis[i] = de[first][i]; dvis[i] = false; } dvis[first] = true; int u =1; for (int i =1;i&lt;=n;i++){ long long min = INF; for (int j =1;j&lt;=n;j++){ if(!dvis[j]&amp;&amp;ddis[j]&lt;min){ min = ddis[j]; u = j; } } dvis[u] = true; for (int v = 1;v&lt;=n;v++){ if(de[u][v]&lt;INF){ if(!dvis[v]&amp;&amp;ddis[v]&gt;ddis[u]+de[u][v]){ ddis[v] = ddis[u]+de[u][v]; } } } }}void SPFA(queue&lt;ll&gt;q,node edge[],ll s){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ ll u = q.front(); q.pop(); vis[u] = false; for (ll i = head[u];i&gt;0;i=edge[i].next){ ll v = edge[i].v; ll w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ while(~scanf("%lld %lld",&amp;n,&amp;m)){ for (int i = 0;i&lt;=n;i++){ for (int j = 0;j&lt;=n;j++) dis[i][j] = INF; } scanf("%lld %lld",&amp;first,&amp;tag); node edge[2*m+1]; cnt = 1; memset(head,0, sizeof(head)); queue&lt;ll&gt;q; queue&lt;ll&gt;q2; for (int i =1;i&lt;=m;i++){ ll u,v,w; scanf("%lld %lld %lld",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); add(edge,v,u,w); } cnt = 1; ll pri[n+1][2]; for (int i = 1;i&lt;=n;i++) scanf("%lld %lld",&amp;pri[i][0],&amp;pri[i][1]); for (int i = 1;i&lt;=n;i++){ memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); SPFA(q,edge,i); for (int j = 1;j&lt;=n;j++){ dis[i][j] = len[j]; } } memset(ddis,0,sizeof(ddis)); memset(dvis,0,sizeof(dvis)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) de[i][j] = i==j? 0:INF; } for (int i = 1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ if(i!=j&amp;&amp;dis[i][j]&lt;=pri[i][0]) de[i][j] = pri[i][1]; } } dijkstra(); if(ddis[tag] == INF) printf("-1\n"); else printf("%lld\n",ddis[tag]); }} 其实可以只写一个最短路算法重复调用的，然而我太弱了，重复调用SPFA总是Runtime Error,迫不得已写了个dijkstra算法 G DH的魔法光束解题思路这题有点意思，看到最后求的是最少需要使用多少次魔法，我想的对每个再第一行的每一个#点当作顶点跑最短路算法，然后计算到第n行最少需要多少次转向。然而1000*1000的矩阵最复杂情况下有10^6个顶点，每个顶点有1999条边，果不其然，runtime error其实即使代码写对了最后也是TLE的，本着偷看题解学习的精神。原来要对行列为点建图！！！ 具体做法是：第1 ～n 行看为第1～n个顶点，第1～m列看为第n+1～n+1+m个顶点，然后对于每个#,相当于边建图，比如 a[i][j] == '#'，那么说明 第 i个顶点和第j+i+n个顶点是相通的，这一点很重要，理由很显然，如果 a[i][j] == '#'，那么说明如果光可以到达a[i][j],便可以使用魔法到第i行或是第j列，那么根据我们建图的定义，即可以到达第i个顶点或是第j+1+n个顶点，那么他们之间肯定是相通的。 权值为1，建好图后跑一遍最短路即可 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INF 9999#define N 1010char a[N][N];vector&lt;int&gt; edge[2010];int d[2010];int n,m;void dijkstra(){ int t; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int ,int&gt;&gt;,greater&lt;pair&lt;int ,int&gt;&gt;&gt;q; for (int i = 0;i&lt;n+m;i++) d[i] = INF; d[0] = 0; q.push(make_pair(0, 0)); while(!q.empty()){ t = q.top().second; q.pop(); for (int i = 0;i&lt;edge[t].size();i++){ if(d[edge[t][i]]&gt;d[t]+1){ d[edge[t][i]]=d[t]+1; q.push(make_pair(d[edge[t][i]], edge[t][i])); } } } return;}int main(){ while(~scanf("%d %d",&amp;n,&amp;m)){ memset(d, 0, sizeof(d)); for (int i =0 ;i&lt;n;i++) scanf("%s",a[i]); for (int i = 0;i&lt;n;i++) for (int j =0 ;j&lt;m;j++) if(a[i][j] == '#'){ edge[i].push_back(j+n); edge[j+n].push_back(i); } dijkstra(); if(d[n-1]!=INF) printf("%d\n",d[n-1]); else printf("-1\n"); for (int i = 0;i&lt;n+m;i++) edge[i].clear(); } return 0;} H DH的满k叉树解题思路传送门 走一波～我还是太弱了 AC代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxN 110#define N 1000000007void findans(long long ansx[],int n,int x){ ansx[0] = 1; for (int i = 1,pos = 0;i&lt;=n;i++){ if(i&gt;=x+1) pos -= ansx[i-x-1]; pos += ansx[i-1]; if(pos&lt;0) pos += N; else pos %= N; ansx[i] = pos; }}int main(){ int n,k,d; while(~scanf("%d %d %d",&amp;n,&amp;k,&amp;d)){ long long ans[maxN],ans2[maxN]; memset(ans,0,sizeof(ans)); memset(ans2,0,sizeof(ans2)); findans(ans, n, k); findans(ans2, n, d-1); if(ans[n]&lt;ans2[n]) ans[n] += N; if(d==1) printf("%lld\n",ans[n]); else printf("%lld\n",ans[n]-ans2[n]); }}]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>算法上机</tag>
        <tag>图算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怦然心动]]></title>
    <url>%2Fheartache.html</url>
    <content type="text"><![CDATA[又看了一遍怦然心动，这已经是三刷这部电影了。每一次看自己的感觉总是那么的相似，心里也总是感慨万千。果然，电影如其名，真的是让人怦然心动～ 场面还是那么的温馨，一棵树，一对人，两个家庭，没有轰轰烈烈的爱情，有的只是一个简简单单的故事，一段细水长流的感情。然而却总是让我有那么一丝丝的触动，就连最后看到两个仅仅牵一牵手，都能让我开心好一阵子。 影片中的人物真的很美好，女主善良，坚强，敢爱敢恨，对于自己有很强的自省意识。同时，也敢于去审视自己喜欢的人，而不是因为爱情而冲昏了自己的头脑，将自己卑微到尘土里。其实，也许这样，才是爱情真正的样子，这样的女生，真的很有吸引力。 女孩的家庭教育，也是很让人印象深刻，哥哥敢于为了自己的音乐梦想而去奋斗；母亲任劳任怨，虽然家里的琐事太多，但是自己也总是用最好的方式去对待这个家庭；父亲是一位艺术家，不仅是生活上的艺术家，也是精神上的艺术家，在很大程度上，他给女孩的心灵启发可能更多。一家人的气氛，真的是家的气氛，更让我感到惊奇的是，父母在吵架后，他们还会依次去给女孩道歉。真的是很让人羡慕～。（我父母也很好，只不过是不一样的好^ _ ^ ） 至于男主，看的真的是让人揪心，小时候有那么一些懦弱，想逃离女主却总是没有勇气，导致自己一次又一次的做出违背内心的选择。或许是父亲和不靠谱的损友的影响，自己的行为总是依赖于别人，也总是一遍又一遍的伤了女主的心。还好，还有爷爷的帮助，帮他找到自己的方向，最后也开始去追求自己想追求的东西。 虽然男主让人揪心，然而，我也是一个男生。说实话，有些方面自己真的是感同身受。都说女生早熟，男生晚熟，以前，我也是一个很木纳的男生，话题终结者也许说的就是我这种人。在某些时候，我也是一个很懦弱的人，很多时候也是按照别人的要求在做事，不敢去违逆别人，也曾撒过小谎而后让自己陷入深深的自责，也许在不经意间，我也曾伤过女孩的心。 虽然自己没有真正意义上的谈过恋爱，但是，高中的时候，自己也是有过喜欢的人的，虽然只是暗恋，但暗恋总是世界上最美好的情感不是。她是一个很好的女孩，也曾让我怦然心动过，那时候的自己，总是喜欢离她靠近一点，喜欢和她做题，说一句话自己就要腼腆一下。那一段时间，对我而言，真的是很美好。 说实话，高一是我最浪的时间，每天都能和好朋友（基友）一起嗨到深夜。 高二是我最开心的时间，没有为什么，也许说句话都能让我开心一下午～～～。 高三是我最努力的时间，每天十二点睡六点起的生活，真的是令我难忘。 高中三年，总归自己还是会因为某些事情有所改变的， 当然，暗恋的结果并不总是好的，有些事情其实自己总归是改变不了的，感情这种事，总归还是两个人的事。想起高三，自己真的是不喜欢那时候的自己，情未了而心已乱，整天愁眉苦脸的，对于别人而言，真的是一个很大的负担。 虽然走不到一起，但我还是会祝福她，因为她真的是一个很好的女孩，希望她能够遇到一个自己真正喜欢的人。上大学一年了，到了现在，有些事情也留在心底了，自己也逐渐看淡了，也懂得了很多，不像过去那么的固执。现在的我，也许也是另有喜欢的人的吧，自己也说不清是一种什么样的感觉，不过，如果可以，在我还不够优秀之前，不希望过多的牵扯她的生活，希望她好好过自己的生活吧。 也许对于男生而言，最痛苦的便是那句：在最没有能力的时候，碰到自己最想照顾一生的人，或许对我来说，好好经营自己的生活，才是我现在应该做的， It’s all right! 大赞爷爷！ Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who’s iridescent, and when you do, nothing will ever compare.有些人沦为平庸浅薄，金玉其外，而败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。 相逢即是缘，点首歌送给你～ 文笔真的是越来越烂了，不开心不开心～～]]></content>
      <categories>
        <category>心灵驿站</category>
        <category>影片</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>台词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷]]></title>
    <url>%2Fluogu5.html</url>
    <content type="text"><![CDATA[P1138 第K小整数洛谷传送门AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n,k; int num = 1; scanf("%d %d",&amp;n,&amp;k); int a[n],b[n]; for (int i =0 ;i&lt;n;i++){ scanf("%d",&amp;a[i]); } sort(a,a+n); b[0] = a[0]; for (int i = 1;i&lt;n;i++){ if(a[i]!=a[i-1]) b[num++] = a[i]; } if(k-1&gt;=num) printf("NO RESULT"); else printf("%d",b[k-1]);}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷p1144]]></title>
    <url>%2Fluogu4.html</url>
    <content type="text"><![CDATA[P1144 最短路计数洛谷传送门AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 99999999#define mod 100003using namespace std;struct node { int u,v,next;};int head[N],len[N],ans[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v){ edge[cnt]={u,v,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; ans[s] = 1; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; if(len[v]&gt; len[u]+1){ len[v] =len[u]+1; ans[v] = ans[u]; if(!vis[v]){ vis[v] =true; q.push(v); } } else if(len[v] == len[u]+1){ ans[v] += ans[u]; ans[v] %= mod; } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); node edge[2*m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v; scanf("%d %d",&amp;u,&amp;v); add(edge,u,v); add(edge,v,u); } SPFA(q, edge); for (int i =1;i&lt;=n;i++) printf("%d\n",ans[i]);}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树Kruscal算法]]></title>
    <url>%2Fkruscal.html</url>
    <content type="text"><![CDATA[Kruscal 算法是另一种计算最小生成树的算法。基本算法思想如下： 建立图，其中有n个顶点，m条边。 将所有的边按照权值从小到大排序。 从权值最小的边开始，依次选取边，如果选的边与之前已选的边之间不构成环，那么将此条边加入到最小生成树的集合中，否则，若构成环，跳过该边，选择下一条继续判断。 依次选取边，直到选取到n-1条边，此时所有的边和顶点构成的即是最小生成树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MaxN 200005 //边的最大数目#define Maxver 5005 //顶点的最大数目struct Edge{ int u,v,w;//u为边的起点，v为边的终点，w为边的权值 bool operator &lt; (const Edge&amp;a)const{//重载小于符号，用于边按照权值排序 return w&lt;a.w; }}edge[MaxN];int fa[Maxver],n,m,ans,eu,ev,cnt;//判断是否构成环的函数，这个函数是为了找到树的根节点，如果新加入的边能够构成环，说明两个点u，v之前都在最小生成树里，那么find(u) == find(v),因为根节点相同。否则，新加入的边不构成环。int find(int x){ return x == fa[x]? x:find(fa[x]);}void kruskal(){ sort(edge,edge+m); for( int i=0;i&lt;m;i++){ eu=find(edge[i].u); ev=find(edge[i].v); if(eu==ev)//如果eu==ev说明新加入的边已经构成环了 continue; ans+=edge[i].w; fa[ev]=eu; if(++cnt==n-1) break; }}int main(){ scanf("%d %d",&amp;n,&amp;m); for( int i=1;i&lt;=n;i++) fa[i]=i;//初始化根节点 for( int i=0;i&lt;m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); edge[i] = {u,v,w}; //相当于scanf("%d %d %d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); } kruskal(); printf("%d\n",ans); return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>图算法</tag>
        <tag>最小生成树</tag>
        <tag>Kruscal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷-KMP算法]]></title>
    <url>%2Fluogu3.html</url>
    <content type="text"><![CDATA[P3371 P3366 【模板】最小生成树洛谷传送门AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxN 1000001#define maxM 2001#define inf 247493646int n,m;int next[maxN];char A[maxN],B[maxN];int main(){ scanf("%s",A); scanf("%s",B); n = strlen(A); m = strlen(B); next[0] = -1; for (int i = 1;i&lt;m;i++){ int j = next[i-1]; while((B[j+1]!=B[i])&amp;&amp;(j&gt;=0)) j = next[j]; if(B[j+1] == B[i]) next[i] = j+1; else next[i] = -1; } int i = 0,j = 0; while(i&lt;n){ if(A[i] == B[j]){ i++;j++; if(j == m){ printf("%d\n",i-m+1); j = next[j-1]+1; } } else{ if(j == 0) i++; else j = next[j-1]+1; } } for (int i = 0;i&lt;m;i++) printf("%d ",next[i]+1); printf("\n"); return 0;}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷2]]></title>
    <url>%2Fluogu22.html</url>
    <content type="text"><![CDATA[P3366 【模板】最小生成树洛谷传送门AC代码：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int u,v,w; bool operator &lt; (const Edge&amp;a){ return w&lt;a.w; }}edge[200005];int fa[5005],n,m;int ans,eu,ev,cnt;int find(int x){ return x==fa[x]? x:find(fa[x]);}void kruskal(){ sort(edge,edge+m); for( int i=0;i&lt;m;i++){ eu=find(edge[i].u); ev=find(edge[i].v); if(eu==ev) continue; ans+=edge[i].w; fa[ev]=eu; if(++cnt==n-1) break; }}int main(){ scanf("%d %d",&amp;n,&amp;m); for( int i=1;i&lt;=n;i++) fa[i]=i; for( int i=0;i&lt;m;i++) scanf("%d %d %d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); kruskal(); printf("%d",ans); return 0;}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树prim算法]]></title>
    <url>%2Fprim.html</url>
    <content type="text"><![CDATA[今天上机刷练习赛，遇到了一道求最小生成树的题目，然后就卡死在这一题了。（emmm,天知道wo上个学期学了图算法后就再也没有碰过有关图的问题了）。 然而题目还是要做的，遂在网上blog里游荡了一番，又重新拾起了遗忘已久的prim和kruskal算法。 至此记录一波～ Prim 算法历史概览 普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法 –百度百科 算法思想Prim算法本质上使用的是一种贪心策略，算法的基本思路如下： 从任意点开始，将该点设为源点。将整个图分为两个部分V，U，其中，V代表已经选过的点的集合，U代表还未选过的点的集合。最初，V中只有源点一个元素。 从U中元素选择一个离V中元素最近的一个点，将该点加入到V中。 重复2操作n-1次，知道所有的点都在V中，此时算法结束。 这里我们以洛谷P3366模版题为例 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MaxInt 999999#define N 5001long long e[N][N],low[N],vis[N];//e代表边集合，low[i]代表从U中点i到V中各元素的最小距离，vis数组记录元素是在V中或是U中long long ans;int n,m,k,flag;void prim(){ int s = 1; //初始low数组 for (int i = 1;i&lt;=n;i++){ low[i] = e[s][i]; } vis[s] = 1;//将s点加入到集合V中 for (int j = 1;j&lt;n;j++){ long long min = MaxInt; //从未被访问的点中选一个最小的点 for (int i = 1;i&lt;=n;i++){ if(!vis[i]&amp;&amp;low[i]&lt;min){//!vis[i]代表元素在U中，low[i]是点i到V的最小距离，这里是为了找一个最近的点 min = low[i]; flag = i; } } ans+=min; vis[flag] = 1;//将点加入到V中 //更新各点的最短距离，因为有新点加入到V中，如果这个新点对U中的点的距离小于原距离，更新此距离 for (int i = 1;i&lt;=n;i++){ if(e[flag][i]&lt;low[i]) low[i] = e[flag][i]; } }}int main(){ scanf("%d%d",&amp;n,&amp;m); for (int i =1 ;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++) e[i][j] = MaxInt; } for (int i = 0;i&lt;m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(e[a][b]&gt;c){//这里是为了对重边进行处理 e[a][b] = c; e[b][a] = c; } } prim(); printf("%lld\n",ans);} 这里是用邻接矩阵存图，算法的时间复杂度为O(n^2).此代码对于洛谷的模版题可以过7个数据点，因为为邻接矩阵存图，空间消耗太大，对于剩下的三个测试点会有MLE错误。]]></content>
      <categories>
        <category>算法</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>图算法</tag>
        <tag>最小生成树</tag>
        <tag>prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷]]></title>
    <url>%2Fluogu.html</url>
    <content type="text"><![CDATA[P3371 【模板】单源最短路径（弱化版）洛谷传送门AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define INF 2147483647typedef long long ll;typedef struct Edge{ int u,v,w,nxt;}edge;edge e[500010];int head[100010];int cnt = 0;void addedge(int u,int v,int w){ e[++cnt] = {u,v,w,head[u]}; head[u] = cnt;}int n,m,s;ll dis[100010];struct node{ ll u,d; bool operator &lt;(const node&amp;rhs)const{ return d&gt;rhs.d; }};void dijkstra(){ for (int i =1;i&lt;=n;i++) dis[i] = INF; dis[s] = 0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node flag = q.top(); q.pop(); ll u = flag.u,d = flag.d; if(d!=dis[u]) continue; for (int i = head[u];i;i=e[i].nxt){ int v = e[i].v,w = e[i].w; if(dis[v]&gt;dis[u]+w){ dis[v] = dis[u]+w; q.push((node){v,dis[v]}); } } }}int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;s); for (int i = 1;i&lt;=m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); } dijkstra(); for (int i = 1;i&lt;=n;i++){ printf("%lld ",dis[i]); } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 2147483647using namespace std;struct node { int u,v,w,next;};int head[N],len[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ edge[cnt]={u,v,w,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;s)){ node edge[m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); } SPFA(q, edge); for (int i =1;i&lt;=n;i++){ printf("%d ",len[i]); } printf("\n"); }}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于新人如何优雅的使用北航OJ]]></title>
    <url>%2F2018c.html</url>
    <content type="text"><![CDATA[使用北航OJ也快一年了，在这里说一说自己的使用经验： C基础数据类型：一般会用的比较多的主要有int,long long,unsigned long long,double,char如果可以的话，记住：能long long不int，能double不float 格式化输入输出：具体你们可以看这个,当然也可以看看其他的资料。 大一的上机，主要以一般的循环和判断为主，所以，要好好掌握循环和判断的写法：for 循环： 123for (int i = 0;i &lt;= n;i++){ ... ...} while 循环：123while(n--){ ... ...} if else语句：12345678if(a){ ... ...}else(b){ ... ...}else{ ... ...} switch语句：123456switch(a){ case 1: ... ...;break; case 2: ... ...;break; case 3: ... ...;break; default: ... ...;break;} 好好掌握循环和判断的写法，剩下的就是要将你们的思路用代码的方式表示出来。 关于OJ：首先，对于新人，在进行第一次北航OJ评测的时候，请务必看一看简介，简介很重要，有关上机的常见错误类型这里都有所提到，且常见写法也会有所提及： 这里谈一谈上机的常见错误类型： WA：代表答案错误，这个错误是最常见的，十次提交九次WA的情况很正常，这个时候就要检查自己的算法是不是有问题了， 自己的思路哪里错了，必要的时候可以试着手动模拟一遍小数据。当然，还有可能是溢出了，如果可以的话，能longlong 不int CE：编译错误，需要检查代码，不过一般提交前会在自己电脑上跑一遍，出现几率较小 Runtime errot: 运行时错误，一般是数组开小了，访问了不存在的区域，试着把数组开大一点，如果需要开很大的数组，比如开10000000的数组，那么最好设置为全局数组，函数内开不了太大的 对于把大数组开在函数内部的同学：函数内部声明的变量默认存储于栈空间，函数的栈空间是比较小的；全局变量是放在堆空间的，堆空间相对较大一些；如果超出了栈空间限制，程序运行会崩溃。所以，递归层数太多、函数内部开大数组等行为会导致运行时错误。—-来自16级助教 其他的错误类型记得看简介，简介里所有的错误类型都有说明。 可能你们会遇到一些题目提示的是输入多组数据,例如这个： 这个没有提示输入的是多少组数据,写法如下： 1234567while (scanf ("%d%d%d",&amp;n,&amp;m,&amp;k)!=EOF){ ... ...}//或者这样写while (~scanf ("%d%d%d",&amp;n,&amp;m,&amp;k)){ ... ...} 关于OJ的评测： OJ的输入评测和输出评测是分开的，也就是说， 输入数据和输出数据是在两个不同的文件中评测，所以，可以不用将全部数据都输入了才输出结果，边输入边输出也是可以的，只要对于一组输入数据，输出结果正确就行,这样写还可以减少debug的难度，因为用数组存答案，中间可能会有bug风险。 例如：对于脸熟赛B题，它给的输入和输出案例是这个：但是，你可以在输入10 5 后就输出它的答案35，而不是等到所有输入数据都输入后才输出。 可以如下所示： 查重 对于提交的代码，助教会查重，所以，不要复制别人的代码，简单的改改变量是没用的，具体机制我也不是很清楚，不过还是自己好好写，最起码，自己要知道为什么这么写，课后能够独立写出来。 关于OJ基本坑不止这些，多上机，多刷题以后就会知道了（脸黑）。 脸熟赛A~H (个人)题解：题目不难，自己多模拟几遍，掌握好基本知识接下来的上机问题就不大。A . 宋老师的见面礼 12345#include &lt;stdio.h&gt;int main(){ printf("Happy National Day!\n"); return 0;} B. 计算器1234567891011#include &lt;stdio.h&gt;int main(){ int n; scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++){ long long a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",a*b-a-b); } return 0;} C. 哦~我的女神！12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ double x1,x2,y1,y2; double dis; scanf("(%lf, %lf) (%lf, %lf)",&amp;x1,&amp;y1,&amp;x2,&amp;y2); dis=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); printf("%.3lfm\n",sqrt(dis)); return 0;} D. 血小板(emmm,这题真的不想写)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;int main(){ printf("/\\::::::::,,,,,,:::,,:,,,,,,,,::,::,,,,,,:::,,:::,:,,:,:,::,,,::,,/\\\n"); printf(":::::::::::,,,:,::::,:,,,,:,:::,,:,,,:,:,,:,,,,:::::::,::::,,:,,,,,,\n"); printf("::::::::::::,,:,:;:,:,,,,,,+: `, ` `.::,:,,,,,::::::::,::,::,,,,,,,\n"); printf(":::::::::,,,::::::,:,,,,:: `` `````````:,,,,,:::::::,::,::,,,,,,,,\n"); printf("::::::,:::;;:,,,::,,:::; ````, ``.`` ` `` :,:,::::,::,:::,:,,,,,,,,\n"); printf(";;;:;;::,:,,:,:,::,:::.``` `` ` ` ` ` ':::::::::,:,,,,,,,,,,,\n"); printf("::,:::::::::::,,,:,:,```` ```` ` `,` `` `..:,,,,:::,,,,,,,,,,,,\n"); printf(":::::::::::,,:::::,, ```` .```,``` ````` ,.,,:::,,,,,,,,,,,,:\n"); printf(":::::::::::::,:::::` `````, + ` `'` `:`,;,,,,,,,,,,,,,,:\n"); printf(":::::::::::::,,::,.```` `` ```:`+` `.`` ;` ```` `.` #,:,,,,,:,,,,,:\n"); printf(":::::::::::::::::, `````` `` . ;`,```` . `' ````,` ,::,,:,,,,,:,\n"); printf(":::::::::::::::,.` `` ``` ```'`. `+`` .::'; `. .,:,,::,,,,,,,\n"); printf(":::::::::::,:;:```` '`.``;```+ ``.# `+' .,` ` ````` ,,,,,:::,,,,\n"); printf("::::::::::::::.`` ` ` ',`+` `: , .`# `;,`` . ```.```;:,,,,,,:::,\n"); printf("::::::::::,:.`,``````:#``;`, `, .`+`````+`' ., ' ```.```;,,,,,,,,,::\n"); printf("::::::::::; ` . ```; `,`# ` `; . #` ` `+`'.::````.``.;,,,,,,,,,:,\n"); printf(":;:::::::;` ` ` `` .``#`; `.` .`+````` `:`,`#` ```.` ,::,,,,,,,,,:\n"); printf(":;:::::::. ` ````` .`+ `, ``` # `,``` `` ; :` ``.``:,:,,,,,,,,::\n"); printf(":;:::::::` .`` ``````'`. . #:`` ``:``` `` `'` .``,.,:,,,,,::::\n"); printf(":;::::::; .`` ``````#` ``' ` ```: `,` `` ````: ` ,`:,,,,,:,:::\n"); printf(":;::::::;``, ` ```` , `+ ```,, `,, ` ```` ` ``::,,,:,:::,\n"); printf(":;:::::::` .` ``` ``+ `` ` :. `.` `` `` ``.: ```` `` ,,,,,,::,::\n"); printf(":;::::::, `.` ``` ```,`` , `` ` `` ````` ` ``, `` ````,:,,,;:,:,:\n"); printf(":;:::::::` ```. ``` ` , ` `,:,````,:,` ` ```,` .` ,,,,:,,:,::\n"); printf(":;:::::::;`` `.`` `` ` , ` :. ` ``` `` ```:`````::`` .:,,:,:,::::\n"); printf(":;::::::::` ` .````` ``., ````` ` ``` `````.,``:``.`,;::::::::,:\n"); printf(":;:::::::::`. `` ` `` .` ```````` ``` ``` `` `````::;,,,,,,::::\n"); printf(":;:::::::,: : `. ``` ``` ``````` `.,::,.`` ` ` ` #;,,,,,,,,:\n"); printf(";;;;;;;;::: ` `.` ` ` `:`````` `,` ` ``` ` `,. `` `` ```,:,,,,,,,,\n"); printf("::::::::::: ` ````` `;``````,` ``.'+'':+,:;;.` ,. ``````,,,,,,,,,,\n"); printf(":::::::::::``, `:````,``````.`` :#++'''';'..,:,,:;``,.` ```:,,,:,,,,\n"); printf(":::::::::::` , ``#:. ``````,``:''''+'''+;'+++#+#,:'';``,` +::,,,:,,\n"); printf(":::::::::::: ,`` ````` :,.:#+'+'''+;';+++#;#,'';'': ``;,,,,,,,,\n"); printf(":::::::::::'``. ``````` , '##@+,+';+#'''':, '+:#;,';;;;:+:,,,,,,,,,\n"); printf(":::::::::::: .;```````: @#++@..,'','+''':, `++`#,#;;:;::,,,,,,,,,,\n"); printf(":::::::::::::`` `````.;@+ '##:..++.,+++':, '++`+;.:::;::::,,,,,,,,\n"); printf(":::::::::::::;';,```.`:,#, `;##...'..;,+'..#'#++ :@ :;::::::,,:,,,,,\n"); printf("::::::::::::::,,:;`.+;.+':` `#+`..::..,;'..++#+; : :::::+',:,,,,:,,\n"); printf("::::::::::::::,,,:::;;.#::,` #+:..,#,...@`.'+#+: : :,':,+',:,:,,,,,\n"); printf(":::::::::::::;::::;,::`#`.#@@##+````````````;#+:`,``+:':.'',,,,,,,,,\n"); printf(";:;;;'';;;:::',:;,:::;`#. ''###'```` ```````;..: '';:.',',,,,,,,,\n"); printf(",;:,:::::::::';;:,::,:`'+`+;++#'```````````` ':``` `:;;:,',;,:,,,,,,\n"); printf(",::,:,:::::::';':+:'::,.+ ::#+:'``````````````:,.``,,';::;::,,,,,,,,\n"); printf("::,,:::::::::':::',::,;``:`;,,,,```````` `````````. ';:;:,,,:,,,,,:\n"); printf(",:,,,;,::::::+:,:'':;,:``` `:;;````````````````````` ';:',,,,,,,,,,,\n"); printf(",::,:,::,:::,+:;'::'::::`.``..,```````````````````` ';:+,,,,,,,,,,,\n"); printf(":,:,,,,;:,:::':;:,::':::'```````````````````````` ;;;#::,,,,,,,,,\n"); printf(",,,,,,,,::,,:':;#;;:;+;;+;``````````````````````` ;;,':',,,,,,,,,\n"); printf(",,,,,,,,:;::,;:''+':::##; ``.``````````````````` ::;,';+:,,,,,,,,\n"); printf(",,,,,,,,,,:,,;:;''+:;:;,,#.````````````````````` ` '::,'::::::::,:,\n"); printf(",,,,,,,,,,,::;;'''':::;..`,``````````` `.,,.```` `';::;';.,,,,,,:,:\n"); printf(":::,,,,,,,,::;;;''''::,;,.```````````:````````` ,+;::''':;:,,,,,,,\n"); printf("::,,,,,,,,,,;';''''+;;,'...``````````````````` `.+';+,+'':':,,,,,,,\n"); printf("::::,,:,,,,,;';'+''';::'',,.`````````````````` ..,,;;:;;+;;::,,,,,,\n"); printf(":,,,,,,,,,:,'';''++'+,,:++:,.````````````````` .,:.:;;:` `',:,,,,,,,\n"); printf("::::,,,,,,,:+';'+'+++;;,##,'..````````````````,,,'`;';;```'.#:,,,,,,\n"); printf("::::,,,,,,,,'''+++#'+++;',,;,',.`````````````,.'`:`'+;;` ```.:,,,,,,\n"); printf("::::,,,:,,,,''''+++#'''',.,:.,.:;`.``````` :;.,.``'':,.``````.::,,,\n"); printf("::::,,,,,,,,++'+++'++`.;;',,.,,.,.::,``````',',```:';:.```````,,,,,,\n"); printf("::,,,,,,,,,:++;+++,.```'+:,,;,.....,,..,,.,.,:````:+;;;```:.```;,,,,\n"); printf(",,,,,,,,,,,:++'+:```````';',,;..............,,``.`,+;' .`:`````.,,,,\n"); printf(",,,,,,,,,,,,+'+;`````````':,,:;,,............`` ``,#;;``:```````::,,\n"); printf(",,,,,,,,,,,,':'.`````````:+;`:,:..,,........`````.,#;;`;```````.::,,\n"); printf(",:,:,,,,,,,,+;.```````````'+```...,........````'``:';.``````',`.`,,,\n"); printf(",,::,,,,,,:,+:``.`,:``````.;+``. .,......````` ``,;'`:````;,,```;,,\n"); printf(",,,,,,,,,,:,+````````:``,`..':`..````````````.:````,;`;``.`,,.````,,\n"); printf(":,,,,,,,,::::``````````,...`#`,`.``:`````````:```:``:`;``.'.,`````:,\n"); printf(":,,:,:;:::,,;.`````````.'`;``````````:, `` .```.'```;`:``.,,```````:\n"); return 0;} E. 萌萌的ASCII码1234567891011121314#include &lt;stdio.h&gt;int main(){ int a; scanf("%d",&amp;a); if(a&lt;=47||(a&gt;=58&amp;&amp;a&lt;=64)||(a&gt;=91 &amp;&amp; a&lt;=96)||a&gt;=123) printf("other character\n"); else if(a&gt;=48 &amp;&amp; a&lt;=57) printf("digit\n"); else if(a&gt;=65 &amp;&amp; a&lt;=90) printf("uppercase\n"); else printf("lowercase\n"); return 0;} F. 原力鉴定12345678910111213#include &lt;stdio.h&gt;int main(){ char a ; int num =0 ; while(scanf("%c",&amp;a)!=EOF){ if(a == 89) num++; if(a=='\n') break; } printf("%d\n",num); return 0;} G. 整数除法123456789101112#include &lt;stdio.h&gt;int main(){ long long a,b; scanf("%lld %lld",&amp;a,&amp;b); if(b == 0) printf("error\n"); else if(a*b &gt;=0||a%b == 0) printf("%lld\n",a/b); else printf("%lld\n",a/b-1); return 0;} H.12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int n; scanf("%d",&amp;n); long long a[n+1]; long long A[n+1],B[n+1]; A[0] = 0;B[0] = 0; for (int i = 1;i&lt;=n;i++){ scanf("%lld",&amp;a[i]); A[i] = A[i-1]+a[i]; B[i] = B[i-1]^a[i]; } printf("%lld\n",A[n]|B[n]); return 0;} 祝刷题愉快！]]></content>
      <tags>
        <tag>北航OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[肖申克的救赎]]></title>
    <url>%2Fmovie1.html</url>
    <content type="text"><![CDATA[It takes a strong man to save himself, and a great man to save another.坚强的人只能救赎自己，伟大的人才能拯救他人 Hope is a good thing, maybe the best of things, and no good thing ever dies.希望是美好的，也许是人间至善，而美好的事物永不消逝. some birds aren’t meant to be caged, that’s all. Their feathers are just too bright…有的鸟是不会被关住的，因为它们的羽毛太美丽了！ I find I’m so excited. I can barely sit still or hold a thought in my head. I think it the excitement only a free man can feel, a free man at the start of a long journey whose conclusion is uncertain. I hope I can make it across the border. I hope to see my friend, and shake his hand. I hope the Pacific is as blue as it has been in my dreams. I hope.我发现自己是如此的激动，以至于不能静静地坐下来思考。我想只有那些重获自由即将踏上新征程的人们才能感受到这种即将揭开未来神秘面纱的激动心情。我希望跨越千山万水握住朋友的手，我希望太平洋的海水如同梦中的一样蓝：我希望…… Fear can hold you prisoner. Hope can set you free. A strong man can save himself. A great man can save another.懦怯囚禁人的灵魂，希望可以感受自由。强者自救，圣者渡人。 These walls are kind of funny like that. First you hate them, then you get u sed to them. Enough time passed, get so you depend on them. That`s institution alized.译文：监狱里的高墙实在是很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就是体制化。 There’s not a day goes by I don’t feel regret. Not because I’m in here, or because you think I should. I look back on the way I was then. Then a young, stupid kid who committed that terrible crime. I want to talk to him. I want to try and talk some sense to him, tell him the way things are. But I can’t. That kid’s long gone and this old man is all that’s left. I got to live with that. Rehabilitated? It’s just a bull………. word. So you go on and stamp your form, sorry, and stop wasting my time. Because to tell you the truth, I don’t give a ………..我无时不刻地对自己的所作所为深感内疚，这不是因为我在这里（指监狱），也不是讨好你们（指假释官）。回首曾经走过的弯路，我多么想对那个犯下重罪的愚蠢的年轻人说些什么，告诉他我现在的感受，告诉他还可以有其他的方式解决问题。可是，我做不到了。那个年轻人早已淹没在岁月的长河里，只留下一个老人孤独地面对过去。重新做人？骗人罢了！小子，别再浪费我的时间了，盖你的章吧，我没什么可说的了。 I guess it comes down to a simple choice:get busy living or get busy dying.生命可以归结为一种简单的选择：要么忙于生存，要么赶着去死。 Give you thoughts to God,and give me your body把思想交给上帝，把身体交给我 A person’s value should not be measured on the day of his worst一个人的价值不应该用他最坏的那天来衡量 相逢即是缘，点首歌送给你～ ps: 本来想写感想的，奈何写作技能已经为负了，写的实在不好emmm]]></content>
      <categories>
        <category>心灵驿站</category>
        <category>影片</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>台词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Linux rm -rf* 命令]]></title>
    <url>%2FLinux-rm-rf.html</url>
    <content type="text"><![CDATA[早就听说过 rm -rf /* 的鼎鼎大名了，然而这个命令可不能轻易尝试，一不小心整个电脑就将成为一个空壳，所有的文件都将disappear，正好，趁着我们软院硬件基础课我们需要使用Ubuntu 系统来进行上机实验，在上课前来了一把rm -rf /*从删库到跑路操作。 不得不说，体验还是极佳的。 首先，进入终端，输入 rm -rf /*命令： 按下回车：我们可以看到，会出现一堆的权限不够的提示： 好了，既然权限不够，那么我们提升权限，改用sudo命令操作： 还是会提示有不被允许的操作： 然而！！！ 过一会后，就会发现，电脑黑屏了！ 没错 ，黑屏，ok,删除结束，重装虚拟机开始:]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 插入音乐与视频]]></title>
    <url>%2FhexoMV.html</url>
    <content type="text"><![CDATA[音乐是不可辜负的 在blog页面中插入音乐主要有下面几种方法： 1. 插入音乐1. 1使用网易云外链播放器使用网易云音乐的外链播放器可以说是最简单的方式了，使用简单，效果显著，对于一般的要求可以满足。 添加单首音乐 使用方法： 进入网易云音乐网页版，搜索你想放上去的歌 进入播放页面，即正常的听歌 在音乐图片的下方，有一个生成外链播放器链接，进入该链接 选择需要放的样式，复制下方的html代码 把代码放到自己想要的地方，md文件是可以嵌入html代码的，想放哪都行～ 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=442016694&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt; 添加网易云歌单方法和添加单首歌曲一样，选择自己喜欢的歌单，生成外链播放器，放在自己想要的位置即可。1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&amp;id=997386069&amp;auto=1&amp;height=430"&gt;&lt;/iframe&gt; 1.2 使用HTML标签插入音乐可以直接使用HTML的标签插入音乐，使用方法如下：1&lt;audio src="https://什么什么什么.mp3" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the audio tag.&lt;/audio&gt; 将这段代码插入到自己想要的地方即可。 1.3 使用aplayer插件插入音乐当然，使用外链播放器一般而言可以满足需求，但对于一些特殊的歌曲，是不能生成外链播放器的，歌单有时也有一些小小的bug。而且没有歌词，功能太单一。这时候，我们就可以借用插件来完成音乐的插入，这也是推荐方法。 音乐插件：首先：我们进入blog根目录，安装Aplayer插件：1$ npm install hexo-tag-aplayer --save 使用方法：按照下面的写法，将自己想要放上去的音乐插入即可。 1{% aplayer "歌曲名" "歌手名" "歌曲的链接，如http://什么什么什么的.mp3" "http://封面图.jpg" "lrc:http://歌词.lrc" %} 使用该方法还可以插入歌单： 插入一般歌单： 1234567891011121314151617181920212223{% aplayerlist %}{ "autoplay": false, "showlrc": 3, "mutex": true, "music": [ { "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" }, { "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" } ]}{% endaplayerlist %} 同步网易云歌单 如果自己想插入几百首歌，该插件还支持另一种很简单的方法，增加MeingJS support同步网易云歌单：首先，进入自己的站点配置文件，在最后加入如下代码，增加MeingJS支持： 12aplayer: meting: true 然后，便是同步网易云歌单：简洁写法：1{% meting "60198" "netease" "playlist" %} 进阶写法：1{% meting "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%} 其中60198是歌单的编号，打开网易云音乐，进入一首歌单，这时网址上的id = 1234567即是编号：12&lt;!-- 后面的数字即是歌单号--&gt;https://music.163.com/#/playlist?id=2442120812 插入后即可放心食用～ 注意：这个歌曲的链接，封面图和歌词文件需要自己上传到空间中。例如七牛云空间就很不错，有10G的免费存储空间，对于一般要求而言已是够用，并且，国内访问速度很快。 关于这个插件的更多信息及参数列表大家可以进入该插件的GitHub地址中查看。 2.插入视频2.1使用HTML标签插入视频我们可以直接使用HTML的标签插入视频，和插入音乐的操作基本一样： 1&lt;video poster="https://封面图.jpg" src="https://什么什么什么的.mp4" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the video tag.&lt;/video&gt; 2.2 使用dplayer插件插入视频使用插件，功能灰常强大，例如可以增加弹幕功能等等，非常建议大家使用： 首先在blog根目录下安装插件：1$ npm install hexo-tag-dplayer --save 然后在自己的blog中的写法： 1{% dplayer "url=https://什么什么什么.mp4" "https://封面图.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %} 要使用弹幕，必须有api和id两项,id的值可以自己随意取，api可以直接使用上方的官网api 关于这个插件的更多信息及参数列表大家可以进入GitHub中查看。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo折腾记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北航算法第一次上机题解]]></title>
    <url>%2FBUAAtest.html</url>
    <content type="text"><![CDATA[写在前面北航新学期开学三个星期，21系也迎来了第一次的上机。上机前自己还是有点忐忑的，不过上机前收到了一个惊喜倒是让自己变得好了很多。至于上机结果，还是有点不尽人意的，不过在可接受范围内。为了给自己留个教训，决定写下题解，以此勉励自己吧 A .水水的斐波那契数列 1. 题目描述相信大家都学过斐波那契数列，虽然很简单，但是斐波那契数列却是很重要的哦，那么让我们来复习一下斐波那契数列吧！ 2. 输入 多组数据输入 每行一个整数n (0&lt;n&lt;=30)3. 输出对于每组数据，输出一行，为斐波那契数列第n项的值 4. 解题思路：这道题的算法不难，首先要牢记斐波那契数列的转换式： f[1] = f[2] = 1 f[n] = f[n-1]+f[n-2] 从这个式子我们很容易想出递归的思路，然而事实上递归是不行的，正确性没问题，但是，效率上完全不切实际。递归算法的时间复杂度为 ,题目n的范围为（0，30}，完全没想法 递归时间复杂度为什么这么高？我们可以这么理解，递归算法每一次都要从头来过，所谓不撞南墙不回头，一条路走到黑。 事实上，大部分的递归算法都可以使用递推来解决，利用数组来保留之前算过的数，可以迅速的得出结果。 另外，我们可以看到，我们每次只是需要数组中的一个数，而数组是不变的，因此，我们可以在输入循环前对数组进行预处理。 时间复杂度为 空间复杂度为 5. AC代码：123456789101112#include &lt;cstdio&gt;long long a[40];int main(){ int n; a[1] = 1; a[2] = 1; for (int i =3;i&lt;39;i++) a[i] = a[i-1]+a[i-2]; while(~scanf("%d",&amp;n)) printf("%lld\n",a[n]); return 0;} B. SkyLee的超位魔法-黑暗丰穰之祭献 1. 题目描述王国军出动24万军队进攻纳萨利克大坟墓，Overlord SkyLee只是微微一笑，区区几十万人就想与我一教高下？让你们见识一下什么叫真正的恐怖吧，超位魔法-黑暗丰穰之祭献！ 刹那间，虚空中出现了一头无比恐怖的怪物，名为黑山羊幼崽。 黑山羊幼崽在出现的第5分钟变为完全体，完全体模式下每分钟可以分裂一次，产生一只新的黑山羊幼崽。（黑山羊幼崽不会被弱小的士兵杀死，也不会消失） 虽然王国军面对黑山羊幼崽只能望风而逃，但SkyLee还是想知道自己的实力有多强大，SkyLee沉浸在自己的强大力量中，无暇思考，你能帮他计算在第n分钟时一共会有多少只黑山羊幼崽么？ 2. 输入 多组数据输入 每行一个整数n，为第n分钟黑山羊幼崽的数量（总数不超过int） 请用递归实现 3. 输出对于每组数据，输出一行，为第n分钟黑山羊幼崽的数量 4. 解题思路同样是斐波那契数列，只是变换了时间间隔，可以看到，第5分钟开始分裂，那么需要4分钟的成长时间，所以 f[n] = f[n-1]+f[n-4] 注意，完全体的幼崽仍然是幼崽emmm 这题要用递归实现，时间复杂度为 空间复杂度 5. AC代码：123456789101112#include &lt;cstdio&gt;int recursion(int n){ return n&lt;=4? 1:recursion(n-1)+recursion(n-4);}int main(){ int n; while(~scanf("%d",&amp;n)){ int ans = recursion(n); printf("%d\n",ans); } return 0;} C. 芸如的入学测试 1. 题目描述芸如是一位天才科学家，为中国阵营效力。她有着出众的才智，在几年的军旅生活中，芸如研制了许多高科技武器，使得中国军队的武备可以与厄普西隆阵营狡猾的研究成果相抗衡，甚至还可以和整个盟军部队分庭抗礼。 芸如很小的时候就已经开始展现自己的才华，并作为最优秀的幼儿被送往保密培训学校。在她入校的第一天，校长决定亲自考一考这位被外界奉为”天才”的小姑娘。 校长的问题是这样的： 在一个长度为N的数字序列A，有Q组询问，每组询问给定l和r：l≤r，请求出A[l]+A[l+1]+…+A[r]的值。 由于这个结果可能很大，最终的结果要对10007取模（即取余数）。 2. 输入 多组数据输入，数据组数不超过10。 第一行是一个数字N，Q，表示序列A中元素的个数和询问组数。（0&lt;N，Q≤1e6） 第二行是N个整数，第i个整数A[i]表示序列A中的第i个元素，保证均为非负整数，且在INT范围内。 接下来Q行，每行是两个用空格分隔的整数l和r（保证l和r不会超出序列A下标的范围，且l≤r）。注意序列A的下标从1开始。 3. 输出对于每组数据，每个询问输出一行，为和值。 4. 解题思路给定l,r求a[l]~a[r]之间的和的值%10007，第一感觉我们是依次相加，然而这么写每一次询问的时间复杂度为 ,时间复杂度不低 我们可以看到，每一次的询问都是对于同一组数组，所以，我们可以预处理一下数组，同时，使用前缀和可以省去每次相加所带来的时间消耗 每一次查询的时间复杂度为 总时间复杂度为 注意，由于N&lt;=1e6所以，我们需要用long long 来保存数组 5. AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;const int N = 1000001;long long a[N];long long sum[N];using namespace std;int main(){ int n,q; while(~scanf("%d %d",&amp;n,&amp;q)){ sum[0] =0 ; for (int i =1;i&lt;=n;i++){ scanf("%lld",&amp;a[i]); sum[i] = sum[i-1]+a[i]; } for (int i =0;i&lt;q;i++){ int l,r; scanf("%d %d",&amp;l,&amp;r); printf("%lld\n",(sum[r] - sum[l-1])%10007); } } return 0;} D 芸茹的课堂测试 1. 题目描述霍纳（Horner）规则是一种将一元n次多项式的求值问题转化为n个一次式的算法。采用最小的乘法运算策略，用于求多项式 在x处的值，转化为 。其伪代码如下： 123y = 0for i = n downto 0 y = ai + x * y 给一个8进制数，这个数很大，他的长度甚至可以达到1e6（即10的6次方）。请输出这个数十进制意义下对1e9+7取模（即取余数）的结果。 2. 输入 第一个数为数据组数n。n &lt;= 10。 每组数据包括一行，一个大整数S，表示给定的8进制数x。S在字符串意义下长度不超过1e6。 3. 输出对于每组数据，输出一行，为其十进制下对1e9+7取模的值。 4. 解题思路秦九韶算法：对于如下公式： 对于一个普通的8位进制数 所以，我们可以利用上面的算法求解十进制数 注意数很长，因此，我们需要用字符来读入数据，通过 a[i] - 0 来转换 为数值b[i] 另外，注意复合的取模运算方法 总时间复杂度为 5. AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;string.h&gt;#define N 1000000007char a[1000001];int b [1000001];int main(){ int n; scanf("%d",&amp;n); for (int i =0;i&lt;n;i++){ memset(a,'\0',sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); int num = strlen(a); for (int j = 0;j&lt;num;j++) b[j] = a[j] - '0'; long long ans = b[0]; for (int j = 1;j&lt;num;j++) ans = (((ans %N) * 8)%N +b[j]%N)%N; printf("%lld\n",ans); }} E 比特手链 1. 题目描述叶姐要想哥赠送一串比特手链，这个手链由0和1组成。想哥买了手链B，无意间得知叶姐想要同样长度的手链A。想哥囊中羞涩，只能手工调整手链。他希望最少通过以下操作进行最少步骤把B变成A。注意：A != B123456789101112131415161718192021对于一个串S：操作1——选择下标i,j，i != j： ·result = S[i] &amp; S[j] ·S[i] = result &amp; S[i] ·S[j] = result &amp; S[j]操作2——选择下标i,j，i != j： ·result = S[i] | S[j] ·S[i] = result | S[i] ·S[j] = result | S[j]操作3——选择下标i,j，i != j： ·result = S[i] ^ S[j] ·S[i] = result ^ S[i] ·S[j] = result ^ S[j]问想哥最少多少步能达成心愿。如果想哥无法达成心愿，输出-1。解题思路： 2. 输入 第一个数为数据组数T 接下来2T行，第2i - 1行为手链B，第2i行为手链A 3. 输出对于每组数据，输出一行，最少的步骤数。特别地，如果无法达成，输出-1。 4. 解题思路：这道题看上去比较的复杂，题目的信息量比较大，并且考点是平时接触得比较少的位运算知识。但是，只要先按照题目给出的意思手写出&amp;、|、^的关系式，会发现，其实这道题的题意还是挺好理解的。让我们来看看这三个操作的意思： &amp;与操作 s[i] s[j] re re&amp;s[i] re&amp;s[j] 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 1 1 1 |或操作 | s[i] | s[j] | re | re\s[i] | re\s[j] || —- |—- | —- | —-|—-|| 0 | 0 | 0 | 0 | 0 || 0 | 1 | 1 | 1 | 1 || 1 | 0 | 1 | 1| 1|| 1 | 1 | 1 |1|1|emmm 用斜线代替一下，直接写好像会解释错误 ^ 异或操作 | s[i] | s[j] | re | re^s[i] | re^s[j] || —- |—- | —- | —-|—-|| 0 | 0 | 0 | 0 | 0 || 0 | 1 | 1 | 1 | 0 || 1 | 0 | 1 | 0| 1|| 1 | 1 | 0 |1|1| 对比上面三个操作，我们可以看到，对于s[i] == s[j]，三个操作均没有变换。而对于s[i]!=s[j]： &amp;操作会让1变成0 |操作会让0变成1 ^操作会交换0和1 所以我们可以考虑以下两种情况： 若手链B全为0 或全为1 ，那么怎么操作都不会改变手链B的值，那么由于B!=A，所以手链B不可能变成手链A, 若手链B不全为0或1，那么，我们一次对比手链A和B，看需要改变0的次数和改变1的次数，那么 ans = max(num0,num1),即先用^操作交换两个数，使0，1互换，不够了再一个一个的变换。 时间复杂度为 5.题解代码12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;char a[1000001];char b[1000001];int main(){ int n; scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++){ scanf("%s",a); scanf("%s",b); int len = strlen(a); int num0 =0 ,num1 = 0,num= 0; for (int i = 0;i&lt;len;i++) if(a[i] == '0') num++; if(num == 0 ||num==len){ printf("-1\n"); } else{ for (int i = 0;i&lt;len;i++){ if(a[i]!=b[i]&amp;&amp;a[i] == '0') num0++; else if(a[i]!=b[i]&amp;&amp;a[i] == '1') num1++; } int max = num0&gt;=num1? num0:num1; printf("%d\n",max); } }} F.SkyLee的艾露猫 1. 题目描述众所周知，怪物猎人中的艾露猫是猎人们狩猎时的好伙伴，不仅可以输出，还可以吸引仇恨，甚至还能帮助采集，实在是居家旅行必备之萌物。 艾露猫很可爱，但是寿命只有短短的20年，艾露猫在出生后2年成年，且成年时每对艾露猫都会在年初产下一对小猫，艾露猫成年10年后进入老年，老年持续8年后遗憾地去世。 现在SkyLee得到了一对可爱的艾露猫，他希望艾露猫越多越好，这样打起龙来就很轻松了。假设艾露猫很传统，都是一夫一妻制，并且生出的小猫也正好为一对，若现在为第1年年初，那么第n年SkyLee一共能有多少只可爱的艾露猫呢？ 2. 输入 第一个数为数据组数T 接下来T行，每行1个整数n(保证艾露猫数量不超过int) 3. 输出对于每组数据，输出一行，为第n年艾露猫的数量 4. 解题思路斐波那契自闭 这一题是斐波那契数列的变形题，我们可以分3步讨论 1: 猫不会死也一直会生育，那么 2: 猫不会死但是十年后不会生育，由于猫还需要2年的时间成长，也就是说，12年前的猫不会再生育了，所以 3：猫会死，那么20年前的猫就不在了， 按照这三步来算，将其分为3个阶段，按照程序来写即可 时间复杂度和一般的递推式斐波那契数列一样，均为 5. 题解代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;long long a[1000001];long long b[10001];long long c[10001];using namespace std;int main(){ int n; a[0] =0;a[1] = 2;a[2] = 2; for (int i = 3;i&lt;=60;i++){ if(i&lt;=12) a[i] = a[i-1]+a[i-2]; else a[i] = a[i-1]+a[i-2]-a[i-12]; } scanf("%d",&amp;n); for (int i= 0;i&lt;n;i++){ int y; scanf("%d",&amp;y); if(y&lt;=20) printf("%lld\n",a[y]); else printf("%lld\n",a[y]-a[y-20]); } return 0;} G. SkyLee在GameStop 1. 题目描述SkyLee有一天逛街的时候看到一家新开业的GameStop，里面卖各种各样的游戏。商店里所有的游戏都按游戏名的字典序从小到大排列好了，小的在里面，大的在外面。SkyLee想要把所有的游戏都试玩（买不起游戏只能看看），但是有些问题： 游戏只能从展示架的一侧拿出来 SkyLee只能拿1个游戏试玩 为了不被商店老板发现蹊跷，SkyLee把游戏光盘放回去的时候总要保证每个展示架的游戏仍然按照字典序从小到大排列(小的在里面，大的在外面) SkyLee虽然没钱但是不可能偷游戏，离开时不能拿着游戏 SkyLee发现了两个空的展示架可以放游戏 SkyLee给摆放有游戏的那个展示架编号1，空的编号2和3。假设SkyLee拿游戏、放游戏和试玩游戏都需要时间，现在由你来帮SkyLee提出一个最快的把所有游戏都试玩完的方案吧。 在同样快的试玩方案中，SkyLee会第一时间试玩他拿到的新游戏，然后尽量把字典序更小的游戏放在编号大的展示架上。 2. 输入 多组数据 每组数据1个数n，表示游戏的数量。1≤n≤10 3. 输出对于每组数据，输出把所有游戏都试玩完的最快方案，按以下要求： 拿出游戏输出一行get game from board i，其中i是展示架的编号。 放回游戏输出一行put game to board i，其中i是展示架的编号。 试玩游戏输出一行playing。 离开商场输出一行leave。 4. 解题思路虽然题目比较怪异，但是本质上还是一个Hanoi问题，只不过有一点点的变形。 对于Hanoi 问题，很显然需要用递归来写，首先我们来考虑一下基本情况： 如果只有一个游戏，那么显然 1-&gt; 3 如果有两个游戏，那么根据题目意思，字典序小的要放到标号大的上面，所以在外面的要先放到2号位置，即1-&gt;2,1-&gt;3; 如果超过两个，要在最快的情况下要完成试玩，先将n-2个移到2号位置，第n-1个移到3号，第n个放回本身位置 这题要注意一下，并不需要所以的游戏放到一个位置，所以 放回本身的位置是合法的 两个的时候也是特殊情况，因为可以分开放 时间复杂度为 5. 题解代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;void move(char from, char to){ printf("get game from board %c\n", from); printf("playing\n"); printf("put game to board %c\n", to);}void moves(char from, char to){ printf("get game from board %c\n", from); printf("put game to board %c\n", to);}void hanoi2(int n, char from, char depend, char to){ if (n == 1) moves(from, to); else{ hanoi2(n - 1, from, to, depend); moves(from, to); hanoi2(n - 1, depend, from, to); }}void hanoi(int n, char from, char depend, char to){ if (n == 1) move(from, to); else{ hanoi(n - 1, from, to, depend); move(from, to); hanoi2(n - 1, depend, from, to); }}int main(){ char a = '1', b = '2', c = '3'; int n; while (cin &gt;&gt; n){ if (n &gt; 2){ hanoi(n - 2, a, c, b); move(a, c); move(a, a); printf("leave\n"); } else if (n == 2){ move(a, b); move(a, c); printf("leave\n"); } else{ move(a, c); printf("leave\n"); } }} H .序列优美差值 1. 题目描述给定一个序列a，询问满足i&lt;j且 L≤a[j]−a[i]≤R的点对（i,j）数量 2. 输入 第一个数为数据组数T，每组数据两行。 第一行为整数n, L, R，表示序列长度，L，R； 接下来一行为空格分隔的n个整数。 T≤10 . n≤1e6 3. 输出对于每组数据，输出一行，点对的数量 4. 解题思路对于求数组中前后元素关系的题，通常而言我们有两种方法： 暴力求解。既然是比大小，那我们只要一个二重循环，将整个数组遍历一遍，记录满足条件的值即可。时间复杂度为 分治法。利用归并排序，在排序的时候利用数组间已经有的大小关系，来算出我们需要的解。时间复杂度为 通常第一种情况比较好写算法，然而时间复杂度过高，所以我们不考虑。 我们来看看第二种算法：考虑两个有序数组L,R,对于它们之间的答案，可分为三部分： L数组中满足条件的对数 R数组中满足条件的对数 L和R数组之间满足条件的对数 可以想到，对于1和2这两部分的答案，在归并的上一次二分时便可得出答案，那么，我们每一次便只需要考虑数组间的对数即可. 5.题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;typedef long long ll;int n,l,r;const int N= 1000010;ll a[N],k[N],ans;void Merge(int left,int right){ if(left &gt;= right) return ; int mid = (left+right)/2; Merge( left, mid); Merge( mid+1, right); int s = left,e = left; for (int i = mid+1;i&lt;=right;i++){ while(a[i] - a[e]&gt;=l&amp;&amp;e&lt;=mid) ++e; while(a[i] - a[s]&gt;r&amp;&amp;s&lt;=mid) ++s; ans += e - s; } int i = left,j = mid+1,p = left; while(i&lt;=mid&amp;&amp;j&lt;=right) k[p++] = a[i]&lt;a[j]? a[i++]:a[j++]; while(i&lt;=mid) k[p++] = a[i++]; while(j&lt;=right) k[p++] = a[j++]; for (int i = left;i&lt;=right;i++) a[i] = k[i];}int main(){ int T; scanf("%d",&amp;T); for (int i = 0;i&lt;T;i++){ ans = 0; scanf("%d %d %d",&amp;n,&amp;l,&amp;r); for (int j = 0;j&lt;n;j++){ scanf("%lld",&amp;a[j]); } Merge(0, n-1); printf("%lld\n",ans); } return 0;}]]></content>
      <categories>
        <category>算法上机</category>
      </categories>
      <tags>
        <tag>北航</tag>
        <tag>算法上机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题优化，打造个人精致网站]]></title>
    <url>%2Fhexo-next.html</url>
    <content type="text"><![CDATA[写在前面 关于个人博客，其实自己很早之前就有了这个打算，然而因为种种的原因（其实就是自己懒），自己一直没有把自己的博客真正的上线，自从四月份写了第一篇blog后就没有碰过了。直到暑假的时候，闲来无事了解算法，观摩了各路大神的blog，才发现，woc，他们的blog怎么这么好看。回想自己大一的一年，貌似自己在这一年内也没有留下些什么，so趁着假期还有时间，将自己荒废已久的blog又拿了出来。 回到正题，既然决定要搭建个人blog，界面ugly怎么行？常言道： 生活还是精致一点的好. –佚名 so经过不断的优化，博主的blog也终于有了一点小起色，才有了现在的界面，个人感觉还是挺ok的。然而，在布置界面的时候，深受网上来来去去搜索的痛苦，所以在这里，本人做一个小结。不敢说能把各位的blog布置的有多好看，但至少，达到我这个程度还是可以的。 1. blog配置 常言道： 任何不谈配置只谈操作的行为都是在耍流氓 –佚名 虽说hexo的版本3.x之间改动也不是很大，next5.x系列和现在的6.x系列也差不多，但是终归还是有那么一点细小的变化，保不准就会有bug生成，所以博主还是提一下自己的blog配置：1Hexo v3.7.1 Next v6.3.0 编辑器：sublime text2 就目前为止，已经算是挺新版的了，当然，大多数配置各版本之间都一样，大家可以酌情考虑版本的选择。 好了！准备进入正题！本blog将带领各位怎么将一个空空如也的blog装饰成博主一样有那么一点起色的网站。博主将从零搭起，所有的操作都将在博主的笔记本上为大家做出示范。 1.1 next主题基本配置首先我们先下载next主题:在这里选择大家需要的版本进行下载。下载完成后，我们的blog便有了两个主要的配置文件，分别是hexo自带的_config.yml文件和next主题自带的_config.yml文件，为了方便，我们将hexo自带的_config.yml文件称为站点配置文件，next主题带的_config.yml文件称为主题配置文件。 首先，第一步我们来更换一下blog的主题，这一步又分为三个小步骤： 将下载下来的next主题文件夹重命名为 next 。 将next文件夹移入blog所在的文件夹的themes 文件夹中，在这里，本人是/blog/themes 修改站点配置文件，在配置文件中搜索theme，将其的值改为next。注意 冒号： 后面一定要有一个空格// 站点_config.yml 文件1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 现在主题就已经配置好了，接下来我们优化一下：继续修改站点配置文件：// 站点_config.yml 文件12345678# Sitetitle: Eternal_zttz #网站的名字subtitle: Saty Hungry，Stay Foolish #网站的副标题description: 个人blog网站 #个人的描述keywords:author: Eternal_zttz #博主的名字language: zh-CN #blog的语言 zh-CN 代表中文timezone: 然后我们修改主题配置文件：// 主题_config.yml 文件 ，搜索Schemes可找到12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 这是next的基本页面布局，默认为Muse布局，在这里，我们选择第三个Pisces 很好，接下来，我们在终端命令行cd 进入blog所在目录，如我是直接命名为blog，所以cd blog: 接着运行： 1hexo s 在浏览器中打开链接：不出意外，打开后会是这么样的界面：ok，我们的blog已经略有起色，样式已经离我们的最终样式八九不离十了，接下来，我们将对其的各个部分进行优化： 2. next主题侧边栏优化在这一部分，我们将对next主题的侧边栏进行优化，主要分为以下几部分： next主题页面生成 个人头像设置 点击个人头像回到主页面 RSS订阅设置 社交栏图标的设置 添加网易云音乐 页面圆角的设置 2.1. next主题页面生成我们可以看到，hexo默认生成的页面只有两个，即首页和归档 页面，对于有强迫症的我来说简直是不！ 协！ ！调，那么接下来，我们来生成我们所需的页面： 2.1.1 页面的生成：首先，我们修改主题配置文件：// 主题_config.yml 文件 ，搜索menu可找到123456789menu: home: / || home #主页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #日程表 #sitemap: /sitemap.xml || sitemap #站点地图 #commonweal: /404/ || heartbeat #公益404 可以看到，大部分的都是注释掉了的，这里我已经把我需要的页面注释解除了，大家可以自行考虑需要的页面。在这里，斜线//之间的文字是 该页面 的名字，如／about／ ，说明我们要跳转的页面的名字为about , 而||后的文字是这个页面的图标名字.这时候我们主页上就可以看到这几个页面，接下来实现页面的跳转： 2.1.2 生成about页面：终端回到blog的根目录.运行：1hexo new page "about" ok,接下来关于页面的markdown自己编写就行。 2.1.3 生成tags页面：终端回到blog的根目录.运行：1hexo new page "tags" 2.1.4 生成categories页面:终端回到categories的根目录.运行：1hexo new page "categories" tags和categorise页面不用自己布局，会自动根据我们的blog的布局好 2.2 站内搜索功能的实现文章写多了，想一篇篇的去寻找可不容易，这时候，我们便需要一个站内的搜索功能，即服务别人，也能方便自己。首先，我们在终端进入blog的根目录下，执行以下命令：1$ npm install hexo-generator-searchdb --save 接着，我们进入站点配置文件_config.yml,在最后新增以下内容：12345search: path: search.xml field: post format: html limit: 10000 最后，打开主题配置文件_config.yml,搜索local_search,其值改为true：123# Local searchlocal_search: enable: true ok，现在站内搜索就大功告成了，一切准备就绪～ 2.3 个人头像设置要设置自己的侧边栏头像，首先，准备一张头像的图片，命名为header.jpg，然后，将图片放在/blog/themes/next/source/images/文件夹下，接着修改主题配置文件，搜索avatar123456789101112avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. - url: /images/avatar.gif + url: /images/header.jpg #图片的地址 # If true, the avatar would be dispalyed in circle. rounded: false #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 #图片的透明度 # If true, the avatar would be rotated with the cursor. rotated: false #设置鼠标移到图片上后头像是否转动 将url里面的值改为图片的地址就可以了， 2.4 点击个人头像回到主页面一般我们看到一个头像，总忍不住去点击它，然而遗憾的是，next主题中默认并没有这个事件，作为一个强迫症，这能忍？？？其实，实现这个功能也很简单：首先，我们打开文件/blog/themes/next/layout/_macro/sidebar.swig,然后，修改以下内容：12345+ &lt;a href="/"&gt; &lt;img class="site-author-image" itemprop="image" src="{{ url_for( theme.avatar.url | default(theme.images + '/avatar.gif') ) }}" alt="{{ author }}" /&gt;+ &lt;/a&gt; ok，重新部署一下，就可以看到效果了 2.5 RSS订阅设置什么？大家都不知道什么是RSS？！！！好吧，其实…本博主也不知道emmm，大家可以看看知乎上有关RSS的文章PS：加上好看就完事了不是,计较干啥首先，我们在终端命令行进入blog所在的目录，运行：1$ npm install --save hexo-generator-feed 接着，打开站点配置文件，在文件的末尾添加：123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开主题配置文件，搜索rss，将其设置成如下所示，注意冒号后要加上一个空格1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: /atom.xml OK，all right 2.6 社交栏设置在主题配置文件中，搜索social，定位到如下代码段，把social的注释取消掉，接下来，就看你需要显示什么社交网站，写上网站名+网址就行。123456789101112social: GitHub: https://github.com/yourname || github #网站名：网址 ||图标名 简书: http://www.jianshu.com || heartbeat #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 2.7 增加网易云音乐音乐是不应该被辜负的，所以，我们可以在侧边栏加上网易云的音乐外链，具体方法为： 打开网易云音乐网页版，选择自己想要放上去的音乐。 在播放页面选择外链播放器，选择一个自己喜欢的样式。 复制其中的代码 打开/blog/themes/next/layout/_macro/sidebar.swig 文件，将代码复制到适合的位置，例如，我是在约161-162行增加1234567891011{% endif %} {% include custom_sidebar %} &lt;/div&gt; &lt;/section&gt; + &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&amp;id=5079881&amp;auto=0&amp;height=32"&gt;&lt;/iframe&gt; {% if display_toc and toc(page.content).length &gt; 1 %} &lt;!--noindex--&gt; &lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; &lt;div class="post-toc"&gt; 重新部署一下网站，就可以看到结果了 2.8 实现侧边栏页面的圆角侧边栏默认是矩形的，可能有一些朋友不是特别喜欢这种尖锐的四角，希望可以稍稍弄的平滑一点，说干就干！下面我们来具体实现它。 首先，我们打开/blog/themes/next/source/css/_variables/Pisces.styl文件，里面定义了一些常量，用来定义blog样式表的值。 然后，找到$border-radius，1234567// Borders// --------------------------------------------------$box-shadow-inner = initial;$box-shadow = initial;$border-radius-inner = initial;$border-radius = initial; 可以看到默认为初始值，即为0改变 为$border-radius = 16px;这时候，下面的一个侧边栏弧度就已经改好了 接着，打开/blog/themes/next/source/css/_schemes/Pisces/_layout.styl文件，diff:true12345678910.header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: $sidebar-desktop; background: white; box-shadow: $box-shadow-inner; -border-radius: $border-radius-inner; +border-radius: $border-radius;//修改上面的侧边栏的弧度 12345678910.content-wrap { float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: white; min-height: 700px; box-shadow: $box-shadow-inner; - border-radius: $border-radius-inner; + border-radius: $border-radius; //修改整个文章页面的弧度 ok 大功告成，到此为止，我们文章的侧边栏就已经优化完毕了，当然，还有更多操作，大家可以去尝试，不过，建议没有把握之前先做好blog的备份。别问我为什么要这么说来看看最终侧边栏效果： 3. next主题主页面优化在上面我们已经把侧边栏的优化都已经完成了，不得不说，刚完成这一部分时我还是有很大的成就感的，接下来，我们将对我们blog的主页面进行进一步的优化。在这一部分，我们将对以下进行操作： blog右上角出现fork me on github 图标 文章背景出现阴影边框 为文章内容添加统计功能，文字总数+阅读时长 为文章中的代码块增加一键复制功能 文章结尾出现“本文结束提示” 增加打赏功能 增加版权信息 修改标签样式 3.1 增加fork me on github 图标在这里(图片版)或这里(文字版)选择一款自己喜欢的图标，然后把图标旁的代码拷贝一份，放到1blog/themes/next/layout/_layout.swig 这个文件夹中，注意要放到&lt;div class="headband"&gt;&lt;/div&gt;的下方OK,这就大功告成了。 3.2 文章背景出现阴影边框这个效果实现起来很简单，打开blog\themes\next\source\css\_custom\custom.styl文件，放入以下代码：12345678// 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 重新部署一下即可实现。 3.3 实现点击出现爱心功能首先，进入该网址,复制页面中的代码，在路径blog/themes/next/source/js/src/中新建love.js文件，将复制的代码粘贴到该文件中。然后打开/blog/themes/next/layout/_layout.swig文件，在该文件的最后增加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 保存后即可看到效果。 3.4 “ 阅读全文 ” 按钮改弧度这个功能和侧边栏改弧度的操作是差不多的，进入文件/blog/themes/next/source/css/_variables/Pisces.styl中，把以下代码修改一下：12345678// Button- $btn-default-radius = 2px+ $btn-default-radius = 16px$btn-default-bg = white$btn-default-color = $text-color$btn-default-border-color = $text-color$btn-default-hover-color = white$btn-default-hover-bg = $black-deep 保存后即可看见效果。 3.5 为文章内容添加统计功能，文字总数+阅读时长这个功能在next主题中已经存在了，我们只需要打开开关就行，具体步骤分为下面三步： 终端进入blog根目录，执行下面代码： 1$ npm install hexo-symbols-count-time --save 进入站点配置文件，为blog配置统计功能，将以下代码复制到最后： 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 进入主题配置文件，搜素symbols_count_time,然后把要显示的改为true.更深入的操作大家可以看github上的说明。PS：如果大家配置完成，然后检查无误后，打开页面依旧没有显示，不要着急，第一次显示可能会比较慢，可以休息一会。（本人多次从头配置都没有效果，一气之下去睡了个午觉，醒来就好了0.0）. 3.6 为文章中的代码块增加一键复制功能在next v6.3.0 版本中，这个功能已经是集成了的，我们进入站点配置文件，搜索copy_button。把它的值改为true即可：12345# Add copy button on codeblock copy_button:copy enable: true #是否开启复制功能 # Show text copy result show_result: true #是否显示提示的复制结果 接着，将鼠标移动到代码块中，便可以看到结果。默认按钮是中文“复制”，若是想改为英文“copy”，可进入blog/themes/next/languages/zh-CN.yml文件中，将下面部分改了即可：12345copy_button: copycopy_success: succeedcopy_failure: failedcopyright: author: 本文作者 这个文件夹中保留了所有的中英部分的对应关系，大家想改各标签名字的话，可以将这个文件中对应的部分改了即可。 3.7 文章结尾提示 “本文结束”在文件夹\themes\next\layout\_macro中新建passage-end-tag.swig文件，并在文件中增加以下代码：12345&lt;div&gt; {% if not is_index %} &lt;div style="text-align:center;color: #555;font-size:14px;"&gt;-------------The End-------------&lt;/div&gt; {% endif %}&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，再这个地方增加如下代码：123456789101112131415 {#####################} {### END POST BODY ###} {#####################}+ &lt;div&gt;+ {% if not is_index %}+ {% include 'passage-end-tag.swig' %}+ {% endif %}+ &lt;/div&gt; {% if theme.wechat_subscriber.enabled and not is_index %} &lt;div&gt; {% include 'wechat-subscriber.swig' %} &lt;/div&gt; {% endif %} 代码如下：12345&lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 最后打开主题配置文件，在文件的最后增加如下代码：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 保存后，打开网页即可看到效果。 3.8 增加打赏功能这个功能很简单，首先，我们将保存微信支付的收款码，将其命名为wechatpay.jpg，并将其保存在/blog/themes/next/source/images/文件中。接着，我们打开主题配置文件，搜索wechatpay，将其前面的注释取消即可：12345#Reward#reward_comment: Donate comment herewechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png 这里我们可以放多种方式的支付码，看个人喜好即可，方法都是一样的。 3.9 增加版权信息博文写好了，怎么说也是作者的一番心血，我们不去抄袭别人的作品，也不希望别人什么都不说带走我们的作品，所以，我们需要在底部做一个版权申明：next主题中现在已经是集成了这个功能的了，我们只在主题配置文件中搜索copyright,并把enable的值改为true即可. 3.10 修改标签样式默认的标签前面是一个#号，我们把它改成标签的符号：修改模板/themes/next/layout/\_macro/post.swig，搜索rel="tag"&gt;#，将# 换成&lt;i class="fa fa-tag"&gt;&lt;/i&gt;即可。 这时候，我们的标签还是有下划线的，要想去掉下滑线，我们可以进入： 1/blog/themes/next/source/css/_custom/custom.styl 文件，在文件最后增加下面代码：123.posts-expand .post-tags a { border-bottom: none;} 即可 4. next主题底部优化侧边栏和主页面的优化都已经实现了，接下来便是底部部分的优化，主要包括下面几个部分： 为文章增加评论功能 增加在线联系Daovoice 修改底部作者图标为跳动的红心 隐藏下方的强力驱动和主题信息 增加本站运行时间 增加站点访问人数和总访问量 4.1 为文章增加评论功能next主题的6.x版里面已经集成了很多评论了，包括Gitment和Valine，大家有兴趣可以去试一试。最开始我用的评论是来必力评论系统， 4.2 增加在线联系Daovoice首先在Daovoice注册账号,邀请码是5f353066，注册完成后会得到一个 app_id声明：这个链接包含了博主的邀请码，注册成功每人会有100元代金券，如果不想使用，可以进入Daovoice官网注册账号。注册成功后，会得到一个app_id:1234daovoice('init', { app_id: "*******"});daovoice('update'); 记下这个app_id的值，然后打开/blog/themes/next/layout/_partials/head/head.swig文件，在如下位置插入代码：123456789{% if theme.daovoice %} &lt;script&gt; (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', { app_id: "{{theme.daovoice_app_id}}" }); daovoice('update'); &lt;/script&gt;{% endif %} 接着打开主题配置文件，在最后写下如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 保存后打开页面即可看见效果。 4.3 修改底部作者图标为跳动的红心这个功能实现起来很简单，打开主题配置文件,搜索animated:把icon 区域的代码做如下修改：123456789# Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 保存即可，如果想改为其他的图标，进入网站修改即可 4.4 隐藏下方的强力驱动和主题信息进入/blog/themes/next/layout/_partials/footer.swig文件，注释掉关于这部分的信息即可：1234567891011121314151617181920{% if theme.footer.powered.enable %} + &lt;!-- &lt;div class="powered-by"&gt;{# #}{{ __('footer.powered', '&lt;a class="theme-link" target="_blank"' + nofollow + ' href="https://hexo.io"&gt;Hexo&lt;/a&gt;') }}{% if theme.footer.powered.version %} v{{ hexo_env('version') }}{% endif %}{##}&lt;/div&gt;{% endif %}{% if theme.footer.powered.enable and theme.footer.theme.enable %} &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;{% endif %}{% if theme.footer.theme.enable %} &lt;div class="theme-info"&gt;{# #}{{ __('footer.theme') }} &amp;mdash; {# #}&lt;a class="theme-link" target="_blank"{{ nofollow }} href="https://github.com/theme-next/hexo-theme-next"&gt;{# #}NexT.{{ theme.scheme }}{# #}&lt;/a&gt;{% if theme.footer.theme.version %} v{{ version }}{% endif %}{##}&lt;/div&gt;+ --&gt;{% endif %} 4.5 增加本站运行时间进入/blog/themes/next/layout/_partials/footer.swig文件，在文件合适的地方放上如下代码：1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt;&lt;script&gt;function show_date_time(){ window.setTimeout("show_date_time()", 1000); BirthDay=new Date("04/17/2018 15:13:14");//修改为自己的blog建站时间 today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}function setzero(i){ if (i&lt;10) {i="0" + i}; return i;}show_date_time();&lt;/script&gt; 如我是在原next主题版本信息的下方增加上面的代码，代码在不同的位置会有不同的效果。 4.6 增加站点访问人数和总访问量打开主题配置文件，搜索busuanzi，将enable的值改为true即可。12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 5. 推荐大佬文章这篇文章主要是为了记录自己搭建blog的经历，因为搭建blog的时候，自己经常忘记优化的方法，特记下以减轻今后搜索的负担：网上有很多特别详细的优化文章，本篇文章也参考了很多，特拿出来与大家分享： hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 强烈推荐最后一篇blog，一路看下来会收获很多很多]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo折腾记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hanoi 问题]]></title>
    <url>%2FHanoi.html</url>
    <content type="text"><![CDATA[一：有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆： 每次只能移动一个圆盘； 大盘不能叠在小盘上面。请输出全部的移动操作。 输入：一个整数n，表示汉诺塔的层数(n &lt; 20)输出：输出把汉诺塔从A移到C的全部操作，每个操作一行 12345678910111213141516#include &lt;cstdio&gt;void Move(int n,char a,char b,char c){ if(n == 1) printf("%c -&gt; %c\n",a,c); else{ Move(n-1,a,c,b); printf("%c -&gt; %c\n",a,c); Move(n-1,b,a,c); }}int main(){ int n; scanf("%d",&amp;n); Move(n,'A','B','C'); return 0;} 输入：13 输出：1234567A -&gt; CA -&gt; BC -&gt; BA -&gt; CB -&gt; AB -&gt; CA -&gt; C 二：还是汉诺塔，但是现在的汉诺塔只能在相邻的柱子间移动（A只能移动到B; B只能移动到A或C; C只能移动到B）。在整个移动过程中，任何时候都保证小盘子只能在大盘子上面。还是给定层数数n，你需要输出把所有盘从A移到C的操作。输入：多组数据输入。第一行是输入数据组数T(0&lt;T&lt;11)。接下来T行，每行一个整数n(0&lt;n&lt;20)，代表层数(盘子个数)。输出：对于每组数据输出其对应的操作，每组数据间用一个空行隔开123456789101112131415161718192021222324#include &lt;cstdio&gt;void Move(int n,char a,char b,char c){ if(n == 1){ printf("%c -&gt; %c\n",a,b); printf("%c -&gt; %c\n",b,c); } else{ Move(n-1,a,b,c); printf("%c -&gt; %c\n",a,b); Move(n-1, c, b, a); printf("%c -&gt; %c\n",b,c); Move(n-1, a, b, c); }}int main(){ int n,t; scanf("%d",&amp;t); for (int i =0;i&lt;t;i++){ scanf("%d",&amp;n); Move(n, 'A', 'B', 'C'); printf("\n"); } return 0;} 运行结果：123456789101112131421A -&gt; BB -&gt; C2A -&gt; BB -&gt; CA -&gt; BC -&gt; BB -&gt; AB -&gt; CA -&gt; BB -&gt; C]]></content>
      <categories>
        <category>算法</category>
        <category>Hanoi</category>
      </categories>
      <tags>
        <tag>算法学习日历</tag>
        <tag>Hanoi</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法堆优化]]></title>
    <url>%2FDijkstraheap.html</url>
    <content type="text"><![CDATA[利用堆来优化普通的Dijkstra算法，能达到更快的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define INF 9999999999999typedef long long ll;typedef struct Edge{ int u,v,w,nxt;}edge;edge e[500010];int head[100010];int cnt = 0;void addedge(int u,int v,int w){ e[++cnt] = {u,v,w,head[u]}; head[u] = cnt;}int n,m,s;ll dis[100010];struct node{ ll u,d; bool operator &lt;(const node&amp;rhs)const{ return d&gt;rhs.d; }};void dijkstra(){ for (int i =1;i&lt;=n;i++) dis[i] = INF; dis[s] = 0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node flag = q.top(); q.pop(); ll u = flag.u,d = flag.d; if(d!=dis[u]) continue; for (int i = head[u];i;i=e[i].nxt){ int v = e[i].v,w = e[i].w; if(dis[v]&gt;dis[u]+w){ dis[v] = dis[u]+w; q.push((node){v,dis[v]}); } } }}int main(){ while(~scanf("%d %d ",&amp;n,&amp;m)){ for (int i = 1;i&lt;=m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); } s = 1; dijkstra(); for (int i = 1;i&lt;=n;i++){ if(dis[i] == INF) printf("-1 "); else printf("%lld ",dis[i]); } printf("\n"); } return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法记录最短路径]]></title>
    <url>%2FDijkstraPath.html</url>
    <content type="text"><![CDATA[用dijkstra算法来记录最短路径方法，用一个数组path[]记录前驱顶点，找到最短路后，从终点倒向追踪，直到找到起点为止。这里可以利用栈来记录路径倒推的过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;#define N 1001#define M 50001#define INF 99999999int n,m,s,t1,t2,t3;;int dis[N],tim[N];bool vis[N];int e[N][N];int pre[N];void dijkstra(){ for (int i = 1;i&lt;=n;i++){ dis[i] = e[s][i]; vis[i] = false; pre[i] = dis[i]!=INF&amp;&amp;i!= s? s:-1; } vis[s] = true; int u =1; for (int i =1;i&lt;=n;i++){ int min = INF; for (int j =1;j&lt;=n;j++){ if(!vis[j]&amp;&amp;dis[j]&lt;min){ min = dis[j]; u = j; } } vis[u] = true; for (int v = 1;v&lt;=n;v++){ if(e[u][v]&lt;INF){ if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v]){ dis[v] = dis[u] +e[u][v]; pre[v] = u; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); if(n ==00&amp;&amp;m==0) return 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) e[i][j] = i==j? 0:INF; } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } int start ,end; while(~scanf("%d %d",&amp;start,&amp;end)){ s = start; dijkstra(); if(start == end){ printf("从%d到%d的最短路径是：%d\n",start,end,start); printf("最短路径：%d\n",0); }else{ stack&lt;int&gt; path; path.push(end); int now = pre[end]; while(1){ path.push(now); if(now == start) break; now = pre[now]; } printf("从%d到%d的最短路线是：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",dis[end]); } }} 程序输入：123456789104 81 2 21 3 61 4 42 3 33 1 73 4 14 1 54 3 124 3 程序输出：12从4到3的最短路线是：4--&gt;1--&gt;2--&gt;3最短路径：10]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法求解最短路问题]]></title>
    <url>%2FDijkstra.html</url>
    <content type="text"><![CDATA[Dijkstra算法思路：Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 1001#define M 50001#define INF 99999999int n,m,s,t1,t2,t3;;int dis[N],tim[N];bool vis[N];int e[N][N];void dijkstra(){ for (int i = 1;i&lt;=n;i++){ dis[i] = e[s][i]; vis[i] = false; } vis[s] = true; int u =1; for (int i =1;i&lt;=n;i++){ int min = INF; for (int j =1;j&lt;=n;j++){ if(!vis[j]&amp;&amp;dis[j]&lt;min){ min = dis[j]; u = j; } } vis[u] = true; for (int v = 1;v&lt;=n;v++){ if(e[u][v]&lt;INF){ if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v]){ dis[v] = dis[u] +e[u][v]; } } } }}int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;s); if(n ==00&amp;&amp;m==0) return 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) e[i][j] = i==j? 0:INF; } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } dijkstra(); for (int i = 1;i&lt;=n;i++) printf("%d ",dis[i]); }]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA算法记录最短路径]]></title>
    <url>%2FSPFAforpath.html</url>
    <content type="text"><![CDATA[路径记录方法：用path[]数组依次记录前驱节点，当找到最短路后，由终点倒推，直到找到起点，可以利用一个栈来维护此过程。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 999999999using namespace std;struct node { int u,v,w,next;};int head[N],len[N],pre[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ edge[cnt] = {u,v,w,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; pre[v] = u;//记录v的前驱节点为u if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); node edge[m+1]; cnt = 1; memset(head, 0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); memset(pre,-1,sizeof(pre)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); //add(edge,v,u,w); } int start,end; while(~scanf("%d %d",&amp;start,&amp;end)){ s = start; SPFA(q, edge); if(start == end){ printf("从%d 到%d的最短路线：%d\n",start,end,start); printf("最短路径：%d",0); }else{ stack&lt;int&gt; path; path.push(end); int now = pre[end];//now 为end的前驱节点，即倒数第二个节点 while(1){ path.push(now); if(now == start)//找到起点，退出 break; now = pre[now];//依次寻找上一个节点的前驱节点 } printf("从%d到%d的最短路线：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",len[end]); } }}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA算法求解最短路问题]]></title>
    <url>%2FSPFA.html</url>
    <content type="text"><![CDATA[SPFA算法实现方法：建立一个队列，初始时队列中只有起始点，用一个数组记录起始点A到其他所有点之间的距离（初始时自身为0，其余为INF),然后利用该点A对与该点直接相通的点Bi进行松弛操作，如果操作成功，而被Bi未在队列中，那么Bi入队。A出队，然后对队列中的下一个元素做相同的操作，直到队列为空，此时数组中的值便是起始点与其余点之间的最短路径。SPFA算法可判断是否存在负权环路，判断方法是检查是否存在一个点进入队列N次。算法复杂度为O(KE).1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 99999999using namespace std;struct node { int u,v,w,next;};int head[N],len[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ /* edge[cnt].u =u; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; */ edge[cnt]={u,v,w,head[u]};//这一句相当于上面四句 head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;s)){//n为顶点数，m为边数，s为起始点 node edge[m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); //add(edge,v,u,w);如果是无向图，则加上这一句，注意加上后edge数组的范围应扩大一倍 } SPFA(q, edge); for (int i =1;i&lt;=n;i++){ printf("%d ",len[i]); } printf("\n"); }}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法记录路径]]></title>
    <url>%2FFloydpath.html</url>
    <content type="text"><![CDATA[关于Floyd算法记录路径的方法一般有两种：一是用path[i][j]记录i的后继节点，二是用path[i][j]记录j的前驱节点。第一种方法：利用path[i][j]记录i的后继节点。路径记录关键代码：1: 初始化：1path[i][j] = j; 2:路径转移记录：1path[i][j] = path[i][k]; 完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define INF 10000001int e[1001][1001];int path[1001][1001];int n,m,t1,t2,t3;void init(){ //初始化e,path数组 memset(e,0,sizeof(e)); memset(path,0,sizeof(path)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(i == j) e[i][j] = 0; else e[i][j] = INF; path[i][j] = j; } } //输入边 for (int i =1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; }}void Floyd(){ //floyd算法 for (int k =1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]){ e[i][j]=e[i][k]+e[k][j]; path[i][j] = path[i][k]; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); init(); Floyd(); int start,end; //得出从start 到end 的路径 while(~scanf("%d %d",&amp;start,&amp;end)){ if(start == end){ printf("从%d到%d的最优路线 : %d\n",start,end,start); printf("最短路径：%d\n",0); } else{ printf("从%d到%d的最短路线：%d",start,end,start); int now= path[start][end]; while(1){ printf("--&gt;%d",now); if(now == end) break; now = path[now][end]; } printf("\n"); printf("最短路径：%d\n",e[start][end]); } } return 0;} 第二种方法：利用path[i][j]记录j的前驱节点,这个方法需要利用stack来输出路径路径记录关键代码：1:初始化：1pre[i][j] = i; 2:路径转移记录：1pre[i][j] = pre[k][j]; 完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define INF 10000001using namespace std;int e[1001][1001];int pre[1001][1001];int n,m,t1,t2,t3;void init(){ memset(e,0,sizeof(e)); memset(pre, 0, sizeof(pre)); for (int i =1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ e[i][j] = i==j? 0:INF; pre[i][j] = i; } } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; }}void Floyd(){ for (int k =1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]){ e[i][j] = e[i][k]+e[k][j]; pre[i][j] = pre[k][j]; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); init(); Floyd(); int start,end; while(~scanf("%d %d",&amp;start,&amp;end)){ if(start == end){ printf("从 %d 到 %d 的最短路线：%d\n",start,end,start); printf("最短路径:%d\n",0); }else{ int now = pre[start][end]; stack&lt;int&gt;path; path.push(end); while(1){ path.push(now); if(now == start) break; now = pre[start][now]; } printf("从 %d 到 %d 的最短路线：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",e[start][end]); } } return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[floyd最短路算法]]></title>
    <url>%2Ffloyd.html</url>
    <content type="text"><![CDATA[Floyd算法是一种动态规划算法，适用于多源最短路径，相对于Dijkstra算法和SPFA算法，其算法复杂度较高，时间复杂度为O(n^3),但其理解较为容易，且代码简单。其基本思想便是对点松弛，在任意 i,j 顶点中，看是否存在顶底k,使得i -&gt; k -&gt; j 的距离小于i -&gt; j的距离，如果存在，则对该两点进行松弛操作。核心代码：12345678for (int k = 1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j] = e[i][k]+e[k][j]; } } } 完整代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int e[1000][1000];int main(){ int n,m,t1,t2,t3; int inf = 9999999; scanf("%d %d",&amp;n,&amp;m); for (int i = 1;i&lt;=n;i++) for (int j =1 ;j&lt;=n;j++){ if(i == j) e[i][j] = 0; else e[i][j] = inf; } for (int i =1 ;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); //这里if主要是为了在存在多条从t1到t2的路径时，记录最短的一条 if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } for (int k = 1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j] = e[i][k]+e[k][j]; } } } for (int i =1 ;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) printf("%d ",e[i][j]); printf("\n"); } return 0;} 测试数据：1234567894 81 2 21 3 61 4 42 3 33 1 73 4 14 1 54 3 12 输出：12340 2 5 4 9 0 3 4 6 8 0 1 5 7 10 0]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言快速排序]]></title>
    <url>%2Fquicksort.html</url>
    <content type="text"><![CDATA[快速排序；基本思路： 从当前参加排序的元素中任选一个元素作为分界元素，与当前参加排序的那些元素进行比较. 凡是小于分界元素的元素都移到分界元素的前面,凡是大于分界元的元素都移到分界元素的后面。 分界元素将当前参加排序的元素分成前后两部分,而分界元素处在排序的最终位置。 然后，分别对这两部分中大小大于1的部分重复上述过程直到排序结束时间复杂度为：O(nlogn) 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}void quicksort(int a[],int left,int right){ if(left&gt;=right) return ; int key = a[left]; int i = left,j = right; while(i&lt;j){ while(i&lt;j&amp;&amp;a[j]&gt;=key) j--; a[i] = a[j]; while(i&lt;j&amp;&amp;a[i]&lt;=key) i++; a[j] = a[i]; } a[i] =key; quicksort(a, left, i-1); quicksort(a, i+1, right);}int main(){ int n; while(~scanf("%d",&amp;n)){ int num[n]; for (int i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); quicksort(num,0,n-1); for (int i = 0;i&lt;n;i++) printf("%d ",num[i]); printf("\n"); }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言堆排序]]></title>
    <url>%2Fheapsort.html</url>
    <content type="text"><![CDATA[堆排序：堆排序可以看成优化版的选择排序 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了其算法时间复杂度为O(nlogn) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a = b;b = t;}void adjust(int a[],int i,int n);void heapSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); heapSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void adjust(int a[],int i,int n){ int j,temp; temp = a[i]; j = 2*i+1; while(j&lt;n){ if(j+1&lt;n&amp;&amp;a[j]&lt;a[j+1]) j++; if(temp&lt;a[j]){ a[(j-1)/2] = a[j]; j = 2*j+1; } else break; } a[(j-1)/2] = temp;}void heapSort(int a[],int n){ int i; for (i = n/2-1;i&gt;=0;i--) adjust(a,i,n); for (i = n-1;i&gt;=1;i--){ SWAP(a[0],a[i]); adjust(a,0,i); }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言冒泡排序]]></title>
    <url>%2Fpupplesort.html</url>
    <content type="text"><![CDATA[冒泡排序是一种简单的排序算法 ，其基本思路如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。其算法时间复杂度为O(n^2). 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}//宏定义交换过程void bubbleSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); bubbleSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void bubbleSort(int a[],int n){ int i,j; int flag = 0; for (i =0 ;i&lt;n;i++){ flag = 0; for (j = 0;j&lt;n-1-i;j++){ if(a[j]&gt;a[j+1]){ SWAP(a[j], a[j+1]); flag=1; } } if(flag == 0) break;//如果某一趟排序没有进行交换，说明排序已经结束，可以略微提高排序的效率 }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言选择排序]]></title>
    <url>%2Fselectsort.html</url>
    <content type="text"><![CDATA[选择排序是基本排序算法之一，其基本思路为： 初始时选择整个序列中最小的一个，将其放在序列开头，此时其便为已排序序列（只有一个元素） 从剩余为排序序列中，选择最小的一个，将其放在已排序序列的末尾 重复 2 过程，直到所有的元素都在已排序序列中 算法时间复杂度为O(n^2). 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}//利用宏定义来定义交换过程，简化代码void selectSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); selectSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void selectSort(int a[],int n){ int i =0,j =0; int min = 0; for ( i =0 ;i&lt;n;i++){ min = i;//将最小值标记为i for (j = i+1;j&lt;n;j++) if(a[j]&lt;a [min])//在i后寻找最小值 min = j; SWAP(a[i],a[min]);//交换i与最小值 }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言插入排序]]></title>
    <url>%2Finsertsort.html</url>
    <content type="text"><![CDATA[插入排序：插入排序算法就如同它的名字，依次在有序数组中插入待排数据，直到所有的元素都已排好序，其基本思路如下： 将第一个元素看成有序数组的首位，其余元素看成待排数据 将第二个元素与第一个元素比较，如果比第一个元素小，则第一个元素后移，然后将第二个元素放在因为后移空出的位置上，此时有序数组中有两个元素 依次重复该过程，将第i个数据与前1···i-1个有序数据比较，如果比其小，则元素后移，直到遇到一个不小于改元素的值，然后将该元素放在空出的位置上插入排序的时间复杂度为O(n^2)，不过，在数据量很小的时候（一般不超过100）,插入排序有着十分迅速的运行速率。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}void insertSort(int a[],int n);int main(){ int n,i; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); insertSort(num,n); for (i =0 ;i&lt;n;i++) printf("%d ",num[i] ); return 0;}void insertSort(int a[],int n){ int i,j,flag; for (i = 0;i&lt;n;i++){ flag = a[i]; for (j =i-1;j&gt;=0;j--){ if(flag&lt;a[j]){ SWAP(a[j], a[j+1]); } else break; } }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言归并排序]]></title>
    <url>%2Fmergesort.html</url>
    <content type="text"><![CDATA[归并排序：归并排序采用了分治的思想，在排好n个数之前，先将前n/2个数和后n/2的数排好，利用递归以此类推，然后将已排好序的两个n/2数组合并为一个长度为n的有序数组。 该算法需要一个作为中间传递已排好序数值的数组 归并排序时间复杂度为O(nlogn)，空间复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#define N 10000int k[N];void merge(int a[],int left,int right){ if(left == right)//递归的终止条件，当left==right时，只有一个元素，此时已是默认排好序的了 return ; int mid = (left+right)/2;//二分 merge(a,left,mid);//排序前半部分 merge(a,mid+1,right);//排序后半部分 int i = left,j =mid+1,p= left;//合并已经排好序的数组 while(i&lt;=mid&amp;&amp;j&lt;=right){ if(a[i]&lt;a[j]) k[p++] = a[i++]; else k[p++] = a[j++]; } while(i&lt;=mid)//如果有数组没有全部合并完，则直接放在合并数组后面 k[p++] = a[i++]; while(j&lt;=right) k[p++] = a[j++]; for (i = left;i&lt;=right;i++)//将k[]返回a[]数组中 a[i] = k[i];}int main(){ int n; scanf("%d",&amp;n); int a[n]; for (int i = 0;i&lt;n;i++) scanf("%d",&amp;a[i]); merge(a,0,n-1); for (int i = 0;i&lt;n;i++) printf("%d ",a[i]); return 0;} 程序输入： 1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的常用命令操作]]></title>
    <url>%2FMyFirstblog.html</url>
    <content type="text"><![CDATA[刚使用hexo时，对于自己如何去部署自己的blog还不太了解，本篇文章做一个小记。注意：执行代码要先在终端中进入存放hexo的文件夹 方式 :$ cd 文件夹名1$ hexo clean 清除缓存文件和已生成的静态文件 1$ hexo new post "the article's title 建立一个新的文件,文件名为“ the article’s title”，此时文件已经建立 好了，接下来就是找到该文件写下自己的blog，hexo的文件符合markdown语法。1$ hexo generate 生成静态文件，可以简写为$ hexo g1$ hexo deploy 部署网站，可以简写为$ hexo d 上面这两条命令可以合并在一起，记为$ hexo g -d 或者$hexo d -g1$ hexo server 启动服务器，可以简写为$ hexo s.默认情况下，访问网址为：http://localhost:4000/. 通常部署blog只需要三步： 使用 $hexo new post "title name" 建立新的文件 使用 markdown语法写自己的blog 使用$hexo g -d部署blog接下来打开网址就可以看到自己的blog已经部署好了]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>部署</tag>
      </tags>
  </entry>
</search>
