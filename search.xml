<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷日刷]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%97%A5%E5%88%B7-1.html</url>
    <content type="text"><![CDATA[P1138 第K小整数洛谷传送门AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n,k; int num = 1; scanf("%d %d",&amp;n,&amp;k); int a[n],b[n]; for (int i =0 ;i&lt;n;i++){ scanf("%d",&amp;a[i]); } sort(a,a+n); b[0] = a[0]; for (int i = 1;i&lt;n;i++){ if(a[i]!=a[i-1]) b[num++] = a[i]; } if(k-1&gt;=num) printf("NO RESULT"); else printf("%d",b[k-1]);}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷p1144]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%97%A5%E5%88%B7p1144.html</url>
    <content type="text"><![CDATA[P1144 最短路计数洛谷传送门AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 99999999#define mod 100003using namespace std;struct node { int u,v,next;};int head[N],len[N],ans[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v){ edge[cnt]={u,v,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; ans[s] = 1; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; if(len[v]&gt; len[u]+1){ len[v] =len[u]+1; ans[v] = ans[u]; if(!vis[v]){ vis[v] =true; q.push(v); } } else if(len[v] == len[u]+1){ ans[v] += ans[u]; ans[v] %= mod; } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); node edge[2*m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v; scanf("%d %d",&amp;u,&amp;v); add(edge,u,v); add(edge,v,u); } SPFA(q, edge); for (int i =1;i&lt;=n;i++) printf("%d\n",ans[i]);}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树Kruscal算法]]></title>
    <url>%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Kruscal%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[Kruscal 算法是另一种计算最小生成树的算法。基本算法思想如下： 建立图，其中有n个顶点，m条边。 将所有的边按照权值从小到大排序。 从权值最小的边开始，依次选取边，如果选的边与之前已选的边之间不构成环，那么将此条边加入到最小生成树的集合中，否则，若构成环，跳过该边，选择下一条继续判断。 依次选取边，直到选取到n-1条边，此时所有的边和顶点构成的即是最小生成树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MaxN 200005 //边的最大数目#define Maxver 5005 //顶点的最大数目struct Edge{ int u,v,w;//u为边的起点，v为边的终点，w为边的权值 bool operator &lt; (const Edge&amp;a)const{//重载小于符号，用于边按照权值排序 return w&lt;a.w; }}edge[MaxN];int fa[Maxver],n,m,ans,eu,ev,cnt;//判断是否构成环的函数，这个函数是为了找到树的根节点，如果新加入的边能够构成环，说明两个点u，v之前都在最小生成树里，那么find(u) == find(v),因为根节点相同。否则，新加入的边不构成环。int find(int x){ return x == fa[x]? x:find(fa[x]);}void kruskal(){ sort(edge,edge+m); for( int i=0;i&lt;m;i++){ eu=find(edge[i].u); ev=find(edge[i].v); if(eu==ev)//如果eu==ev说明新加入的边已经构成环了 continue; ans+=edge[i].w; fa[ev]=eu; if(++cnt==n-1) break; }}int main(){ scanf("%d %d",&amp;n,&amp;m); for( int i=1;i&lt;=n;i++) fa[i]=i;//初始化根节点 for( int i=0;i&lt;m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); edge[i] = {u,v,w}; //相当于scanf("%d %d %d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); } kruskal(); printf("%d\n",ans); return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>图算法</tag>
        <tag>Kruscal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷-KMP算法]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%97%A5%E5%88%B7-KMP%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[P3371 P3366 【模板】最小生成树洛谷传送门AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxN 1000001#define maxM 2001#define inf 247493646int n,m;int next[maxN];char A[maxN],B[maxN];int main(){ scanf("%s",A); scanf("%s",B); n = strlen(A); m = strlen(B); next[0] = -1; for (int i = 1;i&lt;m;i++){ int j = next[i-1]; while((B[j+1]!=B[i])&amp;&amp;(j&gt;=0)) j = next[j]; if(B[j+1] == B[i]) next[i] = j+1; else next[i] = -1; } int i = 0,j = 0; while(i&lt;n){ if(A[i] == B[j]){ i++;j++; if(j == m){ printf("%d\n",i-m+1); j = next[j-1]+1; } } else{ if(j == 0) i++; else j = next[j-1]+1; } } for (int i = 0;i&lt;m;i++) printf("%d ",next[i]+1); printf("\n"); return 0;}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷2]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%97%A5%E5%88%B72.html</url>
    <content type="text"><![CDATA[P3366 【模板】最小生成树洛谷传送门AC代码：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int u,v,w; bool operator &lt; (const Edge&amp;a){ return w&lt;a.w; }}edge[200005];int fa[5005],n,m;int ans,eu,ev,cnt;int find(int x){ return x==fa[x]? x:find(fa[x]);}void kruskal(){ sort(edge,edge+m); for( int i=0;i&lt;m;i++){ eu=find(edge[i].u); ev=find(edge[i].v); if(eu==ev) continue; ans+=edge[i].w; fa[ev]=eu; if(++cnt==n-1) break; }}int main(){ scanf("%d %d",&amp;n,&amp;m); for( int i=1;i&lt;=n;i++) fa[i]=i; for( int i=0;i&lt;m;i++) scanf("%d %d %d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); kruskal(); printf("%d",ans); return 0;}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树prim算法]]></title>
    <url>%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91prim%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[今天上机刷练习赛，遇到了一道求最小生成树的题目，然后就卡死在这一题了。（emmm,天知道wo上个学期学了图算法后就再也没有碰过有关图的问题了）。 然而题目还是要做的，遂在网上blog里游荡了一番，又重新拾起了遗忘已久的prim和kruskal算法。 至此记录一波～ Prim 算法历史概览 普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法 –百度百科 算法思想Prim算法本质上使用的是一种贪心策略，算法的基本思路如下： 从任意点开始，将该点设为源点。将整个图分为两个部分V，U，其中，V代表已经选过的点的集合，U代表还未选过的点的集合。最初，V中只有源点一个元素。 从U中元素选择一个离V中元素最近的一个点，将该点加入到V中。 重复2操作n-1次，知道所有的点都在V中，此时算法结束。 这里我们以洛谷P3366模版题为例 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MaxInt 999999#define N 5001long long e[N][N],low[N],vis[N];//e代表边集合，low[i]代表从U中点i到V中各元素的最小距离，vis数组记录元素是在V中或是U中long long ans;int n,m,k,flag;void prim(){ int s = 1; //初始low数组 for (int i = 1;i&lt;=n;i++){ low[i] = e[s][i]; } vis[s] = 1;//将s点加入到集合V中 for (int j = 1;j&lt;n;j++){ long long min = MaxInt; //从未被访问的点中选一个最小的点 for (int i = 1;i&lt;=n;i++){ if(!vis[i]&amp;&amp;low[i]&lt;min){//!vis[i]代表元素在U中，low[i]是点i到V的最小距离，这里是为了找一个最近的点 min = low[i]; flag = i; } } ans+=min; vis[flag] = 1;//将点加入到V中 //更新各点的最短距离，因为有新点加入到V中，如果这个新点对U中的点的距离小于原距离，更新此距离 for (int i = 1;i&lt;=n;i++){ if(e[flag][i]&lt;low[i]) low[i] = e[flag][i]; } }}int main(){ scanf("%d%d",&amp;n,&amp;m); for (int i =1 ;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++) e[i][j] = MaxInt; } for (int i = 0;i&lt;m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(e[a][b]&gt;c){//这里是为了对重边进行处理 e[a][b] = c; e[b][a] = c; } } prim(); printf("%lld\n",ans);} 这里是用邻接矩阵存图，算法的时间复杂度为O(n^2).此代码对于洛谷的模版题可以过7个数据点，因为为邻接矩阵存图，空间消耗太大，对于剩下的三个测试点会有MLE错误。]]></content>
      <categories>
        <category>算法</category>
        <category>图算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>图算法</tag>
        <tag>prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷日刷]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%97%A5%E5%88%B7.html</url>
    <content type="text"><![CDATA[P3371 【模板】单源最短路径（弱化版）洛谷传送门AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define INF 2147483647typedef long long ll;typedef struct Edge{ int u,v,w,nxt;}edge;edge e[500010];int head[100010];int cnt = 0;void addedge(int u,int v,int w){ e[++cnt] = {u,v,w,head[u]}; head[u] = cnt;}int n,m,s;ll dis[100010];struct node{ ll u,d; bool operator &lt;(const node&amp;rhs)const{ return d&gt;rhs.d; }};void dijkstra(){ for (int i =1;i&lt;=n;i++) dis[i] = INF; dis[s] = 0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node flag = q.top(); q.pop(); ll u = flag.u,d = flag.d; if(d!=dis[u]) continue; for (int i = head[u];i;i=e[i].nxt){ int v = e[i].v,w = e[i].w; if(dis[v]&gt;dis[u]+w){ dis[v] = dis[u]+w; q.push((node){v,dis[v]}); } } }}int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;s); for (int i = 1;i&lt;=m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); } dijkstra(); for (int i = 1;i&lt;=n;i++){ printf("%lld ",dis[i]); } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 2147483647using namespace std;struct node { int u,v,w,next;};int head[N],len[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ edge[cnt]={u,v,w,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;s)){ node edge[m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); } SPFA(q, edge); for (int i =1;i&lt;=n;i++){ printf("%d ",len[i]); } printf("\n"); }}]]></content>
      <categories>
        <category>洛谷日刷</category>
      </categories>
      <tags>
        <tag>洛谷日刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于新人如何优雅的使用北航OJ]]></title>
    <url>%2F2018%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html</url>
    <content type="text"><![CDATA[使用北航OJ也快一年了，在这里说一说自己的使用经验： C基础数据类型：一般会用的比较多的主要有int,long long,unsigned long long,double,char如果可以的话，记住：能long long不int，能double不float 格式化输入输出：具体你们可以看这个,当然也可以看看其他的资料。 大一的上机，主要以一般的循环和判断为主，所以，要好好掌握循环和判断的写法：for 循环： 123for (int i = 0;i &lt;= n;i++){ ... ...} while 循环：123while(n--){ ... ...} if else语句：12345678if(a){ ... ...}else(b){ ... ...}else{ ... ...} switch语句：123456switch(a){ case 1: ... ...;break; case 2: ... ...;break; case 3: ... ...;break; default: ... ...;break;} 好好掌握循环和判断的写法，剩下的就是要将你们的思路用代码的方式表示出来。 关于OJ：首先，对于新人，在进行第一次北航OJ评测的时候，请务必看一看简介，简介很重要，有关上机的常见错误类型这里都有所提到，且常见写法也会有所提及： 这里谈一谈上机的常见错误类型： WA：代表答案错误，这个错误是最常见的，十次提交九次WA的情况很正常，这个时候就要检查自己的算法是不是有问题了， 自己的思路哪里错了，必要的时候可以试着手动模拟一遍小数据。当然，还有可能是溢出了，如果可以的话，能longlong 不int CE：编译错误，需要检查代码，不过一般提交前会在自己电脑上跑一遍，出现几率较小 Runtime errot: 运行时错误，一般是数组开小了，访问了不存在的区域，试着把数组开大一点，如果需要开很大的数组，比如开10000000的数组，那么最好设置为全局数组，函数内开不了太大的 对于把大数组开在函数内部的同学：函数内部声明的变量默认存储于栈空间，函数的栈空间是比较小的；全局变量是放在堆空间的，堆空间相对较大一些；如果超出了栈空间限制，程序运行会崩溃。所以，递归层数太多、函数内部开大数组等行为会导致运行时错误。—-来自16级助教 其他的错误类型记得看简介，简介里所有的错误类型都有说明。 可能你们会遇到一些题目提示的是输入多组数据,例如这个： 这个没有提示输入的是多少组数据,写法如下： 1234567while (scanf ("%d%d%d",&amp;n,&amp;m,&amp;k)!=EOF){ ... ...}//或者这样写while (~scanf ("%d%d%d",&amp;n,&amp;m,&amp;k)){ ... ...} 关于OJ的评测： OJ的输入评测和输出评测是分开的，也就是说， 输入数据和输出数据是在两个不同的文件中评测，所以，可以不用将全部数据都输入了才输出结果，边输入边输出也是可以的，只要对于一组输入数据，输出结果正确就行,这样写还可以减少debug的难度，因为用数组存答案，中间可能会有bug风险。 例如：对于脸熟赛B题，它给的输入和输出案例是这个：但是，你可以在输入10 5 后就输出它的答案35，而不是等到所有输入数据都输入后才输出。 可以如下所示： 查重 对于提交的代码，助教会查重，所以，不要复制别人的代码，简单的改改变量是没用的，具体机制我也不是很清楚，不过还是自己好好写，最起码，自己要知道为什么这么写，课后能够独立写出来。 关于OJ基本坑不止这些，多上机，多刷题以后就会知道了（脸黑）。 脸熟赛A~H (个人)题解：题目不难，自己多模拟几遍，掌握好基本知识接下来的上机问题就不大。A . 宋老师的见面礼 12345#include &lt;stdio.h&gt;int main(){ printf("Happy National Day!\n"); return 0;} B. 计算器1234567891011#include &lt;stdio.h&gt;int main(){ int n; scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++){ long long a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",a*b-a-b); } return 0;} C. 哦~我的女神！12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ double x1,x2,y1,y2; double dis; scanf("(%lf, %lf) (%lf, %lf)",&amp;x1,&amp;y1,&amp;x2,&amp;y2); dis=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); printf("%.3lfm\n",sqrt(dis)); return 0;} D. 血小板(emmm,这题真的不想写)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;int main(){ printf("/\\::::::::,,,,,,:::,,:,,,,,,,,::,::,,,,,,:::,,:::,:,,:,:,::,,,::,,/\\\n"); printf(":::::::::::,,,:,::::,:,,,,:,:::,,:,,,:,:,,:,,,,:::::::,::::,,:,,,,,,\n"); printf("::::::::::::,,:,:;:,:,,,,,,+: `, ` `.::,:,,,,,::::::::,::,::,,,,,,,\n"); printf(":::::::::,,,::::::,:,,,,:: `` `````````:,,,,,:::::::,::,::,,,,,,,,\n"); printf("::::::,:::;;:,,,::,,:::; ````, ``.`` ` `` :,:,::::,::,:::,:,,,,,,,,\n"); printf(";;;:;;::,:,,:,:,::,:::.``` `` ` ` ` ` ':::::::::,:,,,,,,,,,,,\n"); printf("::,:::::::::::,,,:,:,```` ```` ` `,` `` `..:,,,,:::,,,,,,,,,,,,\n"); printf(":::::::::::,,:::::,, ```` .```,``` ````` ,.,,:::,,,,,,,,,,,,:\n"); printf(":::::::::::::,:::::` `````, + ` `'` `:`,;,,,,,,,,,,,,,,:\n"); printf(":::::::::::::,,::,.```` `` ```:`+` `.`` ;` ```` `.` #,:,,,,,:,,,,,:\n"); printf(":::::::::::::::::, `````` `` . ;`,```` . `' ````,` ,::,,:,,,,,:,\n"); printf(":::::::::::::::,.` `` ``` ```'`. `+`` .::'; `. .,:,,::,,,,,,,\n"); printf(":::::::::::,:;:```` '`.``;```+ ``.# `+' .,` ` ````` ,,,,,:::,,,,\n"); printf("::::::::::::::.`` ` ` ',`+` `: , .`# `;,`` . ```.```;:,,,,,,:::,\n"); printf("::::::::::,:.`,``````:#``;`, `, .`+`````+`' ., ' ```.```;,,,,,,,,,::\n"); printf("::::::::::; ` . ```; `,`# ` `; . #` ` `+`'.::````.``.;,,,,,,,,,:,\n"); printf(":;:::::::;` ` ` `` .``#`; `.` .`+````` `:`,`#` ```.` ,::,,,,,,,,,:\n"); printf(":;:::::::. ` ````` .`+ `, ``` # `,``` `` ; :` ``.``:,:,,,,,,,,::\n"); printf(":;:::::::` .`` ``````'`. . #:`` ``:``` `` `'` .``,.,:,,,,,::::\n"); printf(":;::::::; .`` ``````#` ``' ` ```: `,` `` ````: ` ,`:,,,,,:,:::\n"); printf(":;::::::;``, ` ```` , `+ ```,, `,, ` ```` ` ``::,,,:,:::,\n"); printf(":;:::::::` .` ``` ``+ `` ` :. `.` `` `` ``.: ```` `` ,,,,,,::,::\n"); printf(":;::::::, `.` ``` ```,`` , `` ` `` ````` ` ``, `` ````,:,,,;:,:,:\n"); printf(":;:::::::` ```. ``` ` , ` `,:,````,:,` ` ```,` .` ,,,,:,,:,::\n"); printf(":;:::::::;`` `.`` `` ` , ` :. ` ``` `` ```:`````::`` .:,,:,:,::::\n"); printf(":;::::::::` ` .````` ``., ````` ` ``` `````.,``:``.`,;::::::::,:\n"); printf(":;:::::::::`. `` ` `` .` ```````` ``` ``` `` `````::;,,,,,,::::\n"); printf(":;:::::::,: : `. ``` ``` ``````` `.,::,.`` ` ` ` #;,,,,,,,,:\n"); printf(";;;;;;;;::: ` `.` ` ` `:`````` `,` ` ``` ` `,. `` `` ```,:,,,,,,,,\n"); printf("::::::::::: ` ````` `;``````,` ``.'+'':+,:;;.` ,. ``````,,,,,,,,,,\n"); printf(":::::::::::``, `:````,``````.`` :#++'''';'..,:,,:;``,.` ```:,,,:,,,,\n"); printf(":::::::::::` , ``#:. ``````,``:''''+'''+;'+++#+#,:'';``,` +::,,,:,,\n"); printf(":::::::::::: ,`` ````` :,.:#+'+'''+;';+++#;#,'';'': ``;,,,,,,,,\n"); printf(":::::::::::'``. ``````` , '##@+,+';+#'''':, '+:#;,';;;;:+:,,,,,,,,,\n"); printf(":::::::::::: .;```````: @#++@..,'','+''':, `++`#,#;;:;::,,,,,,,,,,\n"); printf(":::::::::::::`` `````.;@+ '##:..++.,+++':, '++`+;.:::;::::,,,,,,,,\n"); printf(":::::::::::::;';,```.`:,#, `;##...'..;,+'..#'#++ :@ :;::::::,,:,,,,,\n"); printf("::::::::::::::,,:;`.+;.+':` `#+`..::..,;'..++#+; : :::::+',:,,,,:,,\n"); printf("::::::::::::::,,,:::;;.#::,` #+:..,#,...@`.'+#+: : :,':,+',:,:,,,,,\n"); printf(":::::::::::::;::::;,::`#`.#@@##+````````````;#+:`,``+:':.'',,,,,,,,,\n"); printf(";:;;;'';;;:::',:;,:::;`#. ''###'```` ```````;..: '';:.',',,,,,,,,\n"); printf(",;:,:::::::::';;:,::,:`'+`+;++#'```````````` ':``` `:;;:,',;,:,,,,,,\n"); printf(",::,:,:::::::';':+:'::,.+ ::#+:'``````````````:,.``,,';::;::,,,,,,,,\n"); printf("::,,:::::::::':::',::,;``:`;,,,,```````` `````````. ';:;:,,,:,,,,,:\n"); printf(",:,,,;,::::::+:,:'':;,:``` `:;;````````````````````` ';:',,,,,,,,,,,\n"); printf(",::,:,::,:::,+:;'::'::::`.``..,```````````````````` ';:+,,,,,,,,,,,\n"); printf(":,:,,,,;:,:::':;:,::':::'```````````````````````` ;;;#::,,,,,,,,,\n"); printf(",,,,,,,,::,,:':;#;;:;+;;+;``````````````````````` ;;,':',,,,,,,,,\n"); printf(",,,,,,,,:;::,;:''+':::##; ``.``````````````````` ::;,';+:,,,,,,,,\n"); printf(",,,,,,,,,,:,,;:;''+:;:;,,#.````````````````````` ` '::,'::::::::,:,\n"); printf(",,,,,,,,,,,::;;'''':::;..`,``````````` `.,,.```` `';::;';.,,,,,,:,:\n"); printf(":::,,,,,,,,::;;;''''::,;,.```````````:````````` ,+;::''':;:,,,,,,,\n"); printf("::,,,,,,,,,,;';''''+;;,'...``````````````````` `.+';+,+'':':,,,,,,,\n"); printf("::::,,:,,,,,;';'+''';::'',,.`````````````````` ..,,;;:;;+;;::,,,,,,\n"); printf(":,,,,,,,,,:,'';''++'+,,:++:,.````````````````` .,:.:;;:` `',:,,,,,,,\n"); printf("::::,,,,,,,:+';'+'+++;;,##,'..````````````````,,,'`;';;```'.#:,,,,,,\n"); printf("::::,,,,,,,,'''+++#'+++;',,;,',.`````````````,.'`:`'+;;` ```.:,,,,,,\n"); printf("::::,,,:,,,,''''+++#'''',.,:.,.:;`.``````` :;.,.``'':,.``````.::,,,\n"); printf("::::,,,,,,,,++'+++'++`.;;',,.,,.,.::,``````',',```:';:.```````,,,,,,\n"); printf("::,,,,,,,,,:++;+++,.```'+:,,;,.....,,..,,.,.,:````:+;;;```:.```;,,,,\n"); printf(",,,,,,,,,,,:++'+:```````';',,;..............,,``.`,+;' .`:`````.,,,,\n"); printf(",,,,,,,,,,,,+'+;`````````':,,:;,,............`` ``,#;;``:```````::,,\n"); printf(",,,,,,,,,,,,':'.`````````:+;`:,:..,,........`````.,#;;`;```````.::,,\n"); printf(",:,:,,,,,,,,+;.```````````'+```...,........````'``:';.``````',`.`,,,\n"); printf(",,::,,,,,,:,+:``.`,:``````.;+``. .,......````` ``,;'`:````;,,```;,,\n"); printf(",,,,,,,,,,:,+````````:``,`..':`..````````````.:````,;`;``.`,,.````,,\n"); printf(":,,,,,,,,::::``````````,...`#`,`.``:`````````:```:``:`;``.'.,`````:,\n"); printf(":,,:,:;:::,,;.`````````.'`;``````````:, `` .```.'```;`:``.,,```````:\n"); return 0;} E. 萌萌的ASCII码1234567891011121314#include &lt;stdio.h&gt;int main(){ int a; scanf("%d",&amp;a); if(a&lt;=47||(a&gt;=58&amp;&amp;a&lt;=64)||(a&gt;=91 &amp;&amp; a&lt;=96)||a&gt;=123) printf("other character\n"); else if(a&gt;=48 &amp;&amp; a&lt;=57) printf("digit\n"); else if(a&gt;=65 &amp;&amp; a&lt;=90) printf("uppercase\n"); else printf("lowercase\n"); return 0;} F. 原力鉴定12345678910111213#include &lt;stdio.h&gt;int main(){ char a ; int num =0 ; while(scanf("%c",&amp;a)!=EOF){ if(a == 89) num++; if(a=='\n') break; } printf("%d\n",num); return 0;} G. 整数除法123456789101112#include &lt;stdio.h&gt;int main(){ long long a,b; scanf("%lld %lld",&amp;a,&amp;b); if(b == 0) printf("error\n"); else if(a*b &gt;=0||a%b == 0) printf("%lld\n",a/b); else printf("%lld\n",a/b-1); return 0;} H.12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int n; scanf("%d",&amp;n); long long a[n+1]; long long A[n+1],B[n+1]; A[0] = 0;B[0] = 0; for (int i = 1;i&lt;=n;i++){ scanf("%lld",&amp;a[i]); A[i] = A[i-1]+a[i]; B[i] = B[i-1]^a[i]; } printf("%lld\n",A[n]|B[n]); return 0;} 祝刷题愉快！]]></content>
      <tags>
        <tag>北航OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[肖申克的救赎]]></title>
    <url>%2F%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E.html</url>
    <content type="text"><![CDATA[It takes a strong man to save himself, and a great man to save another.坚强的人只能救赎自己，伟大的人才能拯救他人 Hope is a good thing, maybe the best of things, and no good thing ever dies.希望是美好的，也许是人间至善，而美好的事物永不消逝. some birds aren’t meant to be caged, that’s all. Their feathers are just too bright…有的鸟是不会被关住的，因为它们的羽毛太美丽了！ I find I’m so excited. I can barely sit still or hold a thought in my head. I think it the excitement only a free man can feel, a free man at the start of a long journey whose conclusion is uncertain. I hope I can make it across the border. I hope to see my friend, and shake his hand. I hope the Pacific is as blue as it has been in my dreams. I hope.我发现自己是如此的激动，以至于不能静静地坐下来思考。我想只有那些重获自由即将踏上新征程的人们才能感受到这种即将揭开未来神秘面纱的激动心情。我希望跨越千山万水握住朋友的手，我希望太平洋的海水如同梦中的一样蓝：我希望…… Fear can hold you prisoner. Hope can set you free. A strong man can save himself. A great man can save another.懦怯囚禁人的灵魂，希望可以感受自由。强者自救，圣者渡人。 These walls are kind of funny like that. First you hate them, then you get u sed to them. Enough time passed, get so you depend on them. That`s institution alized.译文：监狱里的高墙实在是很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就是体制化。 There’s not a day goes by I don’t feel regret. Not because I’m in here, or because you think I should. I look back on the way I was then. Then a young, stupid kid who committed that terrible crime. I want to talk to him. I want to try and talk some sense to him, tell him the way things are. But I can’t. That kid’s long gone and this old man is all that’s left. I got to live with that. Rehabilitated? It’s just a bull………. word. So you go on and stamp your form, sorry, and stop wasting my time. Because to tell you the truth, I don’t give a ………..我无时不刻地对自己的所作所为深感内疚，这不是因为我在这里（指监狱），也不是讨好你们（指假释官）。回首曾经走过的弯路，我多么想对那个犯下重罪的愚蠢的年轻人说些什么，告诉他我现在的感受，告诉他还可以有其他的方式解决问题。可是，我做不到了。那个年轻人早已淹没在岁月的长河里，只留下一个老人孤独地面对过去。重新做人？骗人罢了！小子，别再浪费我的时间了，盖你的章吧，我没什么可说的了。 I guess it comes down to a simple choice:get busy living or get busy dying.生命可以归结为一种简单的选择：要么忙于生存，要么赶着去死。 Give you thoughts to God,and give me your body把思想交给上帝，把身体交给我 A person’s value should not be measured on the day of his worst一个人的价值不应该用他最坏的那天来衡量 相逢即是缘，点首歌送给你～ ps: 本来想写感想的，奈何写作技能已经为负了，写的实在不好emmm]]></content>
      <categories>
        <category>心灵驿站</category>
        <category>影片</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>台词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Linux rm -rf* 命令]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Linux-rm-rf-%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[早就听说过 rm -rf /* 的鼎鼎大名了，然而这个命令可不能轻易尝试，一不小心整个电脑就将成为一个空壳，所有的文件都将disappear，正好，趁着我们软院硬件基础课我们需要使用Ubuntu 系统来进行上机实验，在上课前来了一把rm -rf /*从删库到跑路操作。 不得不说，体验还是极佳的。 首先，进入终端，输入 rm -rf /*命令： 按下回车：我们可以看到，会出现一堆的权限不够的提示： 好了，既然权限不够，那么我们提升权限，改用sudo命令操作： 还是会提示有不被允许的操作： 然而！！！ 过一会后，就会发现，电脑黑屏了！ 没错 ，黑屏，ok,删除结束，重装虚拟机开始:]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 插入音乐与视频]]></title>
    <url>%2Fhexo-%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E4%B8%8E%E8%A7%86%E9%A2%91.html</url>
    <content type="text"><![CDATA[音乐是不可辜负的 在blog页面中插入音乐主要有下面几种方法： 1. 插入音乐1. 1使用网易云外链播放器使用网易云音乐的外链播放器可以说是最简单的方式了，使用简单，效果显著，对于一般的要求可以满足。 添加单首音乐 使用方法： 进入网易云音乐网页版，搜索你想放上去的歌 进入播放页面，即正常的听歌 在音乐图片的下方，有一个生成外链播放器链接，进入该链接 选择需要放的样式，复制下方的html代码 把代码放到自己想要的地方，md文件是可以嵌入html代码的，想放哪都行～ 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=442016694&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt; 添加网易云歌单方法和添加单首歌曲一样，选择自己喜欢的歌单，生成外链播放器，放在自己想要的位置即可。1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&amp;id=997386069&amp;auto=1&amp;height=430"&gt;&lt;/iframe&gt; 1.2 使用HTML标签插入音乐可以直接使用HTML的标签插入音乐，使用方法如下：1&lt;audio src="https://什么什么什么.mp3" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the audio tag.&lt;/audio&gt; 将这段代码插入到自己想要的地方即可。 1.3 使用aplayer插件插入音乐当然，使用外链播放器一般而言可以满足需求，但对于一些特殊的歌曲，是不能生成外链播放器的，歌单有时也有一些小小的bug。而且没有歌词，功能太单一。这时候，我们就可以借用插件来完成音乐的插入，这也是推荐方法。 音乐插件：首先：我们进入blog根目录，安装Aplayer插件：1$ npm install hexo-tag-aplayer --save 使用方法：按照下面的写法，将自己想要放上去的音乐插入即可。 1{% aplayer "歌曲名" "歌手名" "歌曲的链接，如http://什么什么什么的.mp3" "http://封面图.jpg" "lrc:http://歌词.lrc" %} 使用该方法还可以插入歌单： 插入一般歌单： 1234567891011121314151617181920212223{% aplayerlist %}{ "autoplay": false, "showlrc": 3, "mutex": true, "music": [ { "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" }, { "title": "歌曲名", "author": "歌手名", "url": "https://什么什么什么.mp3", "pic": "https://封面图.jpg", "lrc": "https://歌词.lrc" } ]}{% endaplayerlist %} 同步网易云歌单 如果自己想插入几百首歌，该插件还支持另一种很简单的方法，增加MeingJS support同步网易云歌单：首先，进入自己的站点配置文件，在最后加入如下代码，增加MeingJS支持： 12aplayer: meting: true 然后，便是同步网易云歌单：简洁写法：1{% meting "60198" "netease" "playlist" %} 进阶写法：1{% meting "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%} 其中60198是歌单的编号，打开网易云音乐，进入一首歌单，这时网址上的id = 1234567即是编号：12&lt;!-- 后面的数字即是歌单号--&gt;https://music.163.com/#/playlist?id=2442120812 插入后即可放心食用～ 注意：这个歌曲的链接，封面图和歌词文件需要自己上传到空间中。例如七牛云空间就很不错，有10G的免费存储空间，对于一般要求而言已是够用，并且，国内访问速度很快。 关于这个插件的更多信息及参数列表大家可以进入该插件的GitHub地址中查看。 2.插入视频2.1使用HTML标签插入视频我们可以直接使用HTML的标签插入视频，和插入音乐的操作基本一样： 1&lt;video poster="https://封面图.jpg" src="https://什么什么什么的.mp4" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the video tag.&lt;/video&gt; 2.2 使用dplayer插件插入视频使用插件，功能灰常强大，例如可以增加弹幕功能等等，非常建议大家使用： 首先在blog根目录下安装插件：1$ npm install hexo-tag-dplayer --save 然后在自己的blog中的写法： 1{% dplayer "url=https://什么什么什么.mp4" "https://封面图.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %} 要使用弹幕，必须有api和id两项,id的值可以自己随意取，api可以直接使用上方的官网api 关于这个插件的更多信息及参数列表大家可以进入GitHub中查看。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo折腾记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北航算法第一次上机题解]]></title>
    <url>%2F%E5%8C%97%E8%88%AA%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3.html</url>
    <content type="text"><![CDATA[写在前面北航新学期开学三个星期，21系也迎来了第一次的上机。上机前自己还是有点忐忑的，不过上机前收到了一个惊喜倒是让自己变得好了很多。至于上机结果，还是有点不尽人意的，不过在可接受范围内。为了给自己留个教训，决定写下题解，以此勉励自己吧 A .水水的斐波那契数列 1. 题目描述相信大家都学过斐波那契数列，虽然很简单，但是斐波那契数列却是很重要的哦，那么让我们来复习一下斐波那契数列吧！ 2. 输入 多组数据输入 每行一个整数n (0&lt;n&lt;=30)3. 输出对于每组数据，输出一行，为斐波那契数列第n项的值 4. 解题思路：这道题的算法不难，首先要牢记斐波那契数列的转换式： f[1] = f[2] = 1 f[n] = f[n-1]+f[n-2] 从这个式子我们很容易想出递归的思路，然而事实上递归是不行的，正确性没问题，但是，效率上完全不切实际。递归算法的时间复杂度为 ,题目n的范围为（0，30}，完全没想法 递归时间复杂度为什么这么高？我们可以这么理解，递归算法每一次都要从头来过，所谓不撞南墙不回头，一条路走到黑。 事实上，大部分的递归算法都可以使用递推来解决，利用数组来保留之前算过的数，可以迅速的得出结果。 另外，我们可以看到，我们每次只是需要数组中的一个数，而数组是不变的，因此，我们可以在输入循环前对数组进行预处理。 时间复杂度为 空间复杂度为 5. AC代码：123456789101112#include &lt;cstdio&gt;long long a[40];int main(){ int n; a[1] = 1; a[2] = 1; for (int i =3;i&lt;39;i++) a[i] = a[i-1]+a[i-2]; while(~scanf("%d",&amp;n)) printf("%lld\n",a[n]); return 0;} B. SkyLee的超位魔法-黑暗丰穰之祭献 1. 题目描述王国军出动24万军队进攻纳萨利克大坟墓，Overlord SkyLee只是微微一笑，区区几十万人就想与我一教高下？让你们见识一下什么叫真正的恐怖吧，超位魔法-黑暗丰穰之祭献！ 刹那间，虚空中出现了一头无比恐怖的怪物，名为黑山羊幼崽。 黑山羊幼崽在出现的第5分钟变为完全体，完全体模式下每分钟可以分裂一次，产生一只新的黑山羊幼崽。（黑山羊幼崽不会被弱小的士兵杀死，也不会消失） 虽然王国军面对黑山羊幼崽只能望风而逃，但SkyLee还是想知道自己的实力有多强大，SkyLee沉浸在自己的强大力量中，无暇思考，你能帮他计算在第n分钟时一共会有多少只黑山羊幼崽么？ 2. 输入 多组数据输入 每行一个整数n，为第n分钟黑山羊幼崽的数量（总数不超过int） 请用递归实现 3. 输出对于每组数据，输出一行，为第n分钟黑山羊幼崽的数量 4. 解题思路同样是斐波那契数列，只是变换了时间间隔，可以看到，第5分钟开始分裂，那么需要4分钟的成长时间，所以 f[n] = f[n-1]+f[n-4] 注意，完全体的幼崽仍然是幼崽emmm 这题要用递归实现，时间复杂度为 空间复杂度 5. AC代码：123456789101112#include &lt;cstdio&gt;int recursion(int n){ return n&lt;=4? 1:recursion(n-1)+recursion(n-4);}int main(){ int n; while(~scanf("%d",&amp;n)){ int ans = recursion(n); printf("%d\n",ans); } return 0;} C. 芸如的入学测试 1. 题目描述芸如是一位天才科学家，为中国阵营效力。她有着出众的才智，在几年的军旅生活中，芸如研制了许多高科技武器，使得中国军队的武备可以与厄普西隆阵营狡猾的研究成果相抗衡，甚至还可以和整个盟军部队分庭抗礼。 芸如很小的时候就已经开始展现自己的才华，并作为最优秀的幼儿被送往保密培训学校。在她入校的第一天，校长决定亲自考一考这位被外界奉为”天才”的小姑娘。 校长的问题是这样的： 在一个长度为N的数字序列A，有Q组询问，每组询问给定l和r：l≤r，请求出A[l]+A[l+1]+…+A[r]的值。 由于这个结果可能很大，最终的结果要对10007取模（即取余数）。 2. 输入 多组数据输入，数据组数不超过10。 第一行是一个数字N，Q，表示序列A中元素的个数和询问组数。（0&lt;N，Q≤1e6） 第二行是N个整数，第i个整数A[i]表示序列A中的第i个元素，保证均为非负整数，且在INT范围内。 接下来Q行，每行是两个用空格分隔的整数l和r（保证l和r不会超出序列A下标的范围，且l≤r）。注意序列A的下标从1开始。 3. 输出对于每组数据，每个询问输出一行，为和值。 4. 解题思路给定l,r求a[l]~a[r]之间的和的值%10007，第一感觉我们是依次相加，然而这么写每一次询问的时间复杂度为 ,时间复杂度不低 我们可以看到，每一次的询问都是对于同一组数组，所以，我们可以预处理一下数组，同时，使用前缀和可以省去每次相加所带来的时间消耗 每一次查询的时间复杂度为 总时间复杂度为 注意，由于N&lt;=1e6所以，我们需要用long long 来保存数组 5. AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;const int N = 1000001;long long a[N];long long sum[N];using namespace std;int main(){ int n,q; while(~scanf("%d %d",&amp;n,&amp;q)){ sum[0] =0 ; for (int i =1;i&lt;=n;i++){ scanf("%lld",&amp;a[i]); sum[i] = sum[i-1]+a[i]; } for (int i =0;i&lt;q;i++){ int l,r; scanf("%d %d",&amp;l,&amp;r); printf("%lld\n",(sum[r] - sum[l-1])%10007); } } return 0;} D 芸茹的课堂测试 1. 题目描述霍纳（Horner）规则是一种将一元n次多项式的求值问题转化为n个一次式的算法。采用最小的乘法运算策略，用于求多项式 在x处的值，转化为 。其伪代码如下： 123y = 0for i = n downto 0 y = ai + x * y 给一个8进制数，这个数很大，他的长度甚至可以达到1e6（即10的6次方）。请输出这个数十进制意义下对1e9+7取模（即取余数）的结果。 2. 输入 第一个数为数据组数n。n &lt;= 10。 每组数据包括一行，一个大整数S，表示给定的8进制数x。S在字符串意义下长度不超过1e6。 3. 输出对于每组数据，输出一行，为其十进制下对1e9+7取模的值。 4. 解题思路秦九韶算法：对于如下公式： 对于一个普通的8位进制数 所以，我们可以利用上面的算法求解十进制数 注意数很长，因此，我们需要用字符来读入数据，通过 a[i] - 0 来转换 为数值b[i] 另外，注意复合的取模运算方法 总时间复杂度为 5. AC代码：123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;string.h&gt;#define N 1000000007char a[1000001];int b [1000001];int main(){ int n; scanf("%d",&amp;n); for (int i =0;i&lt;n;i++){ memset(a,'\0',sizeof(a)); memset(b,0,sizeof(b)); scanf("%s",a); int num = strlen(a); for (int j = 0;j&lt;num;j++) b[j] = a[j] - '0'; long long ans = b[0]; for (int j = 1;j&lt;num;j++) ans = (((ans %N) * 8)%N +b[j]%N)%N; printf("%lld\n",ans); }} E 比特手链 1. 题目描述叶姐要想哥赠送一串比特手链，这个手链由0和1组成。想哥买了手链B，无意间得知叶姐想要同样长度的手链A。想哥囊中羞涩，只能手工调整手链。他希望最少通过以下操作进行最少步骤把B变成A。注意：A != B123456789101112131415161718192021对于一个串S：操作1——选择下标i,j，i != j： ·result = S[i] &amp; S[j] ·S[i] = result &amp; S[i] ·S[j] = result &amp; S[j]操作2——选择下标i,j，i != j： ·result = S[i] | S[j] ·S[i] = result | S[i] ·S[j] = result | S[j]操作3——选择下标i,j，i != j： ·result = S[i] ^ S[j] ·S[i] = result ^ S[i] ·S[j] = result ^ S[j]问想哥最少多少步能达成心愿。如果想哥无法达成心愿，输出-1。解题思路： 2. 输入 第一个数为数据组数T 接下来2T行，第2i - 1行为手链B，第2i行为手链A 3. 输出对于每组数据，输出一行，最少的步骤数。特别地，如果无法达成，输出-1。 4. 解题思路：这道题看上去比较的复杂，题目的信息量比较大，并且考点是平时接触得比较少的位运算知识。但是，只要先按照题目给出的意思手写出&amp;、|、^的关系式，会发现，其实这道题的题意还是挺好理解的。让我们来看看这三个操作的意思： &amp;与操作 s[i] s[j] re re&amp;s[i] re&amp;s[j] 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 1 1 1 |或操作 | s[i] | s[j] | re | re\s[i] | re\s[j] || —- |—- | —- | —-|—-|| 0 | 0 | 0 | 0 | 0 || 0 | 1 | 1 | 1 | 1 || 1 | 0 | 1 | 1| 1|| 1 | 1 | 1 |1|1|emmm 用斜线代替一下，直接写好像会解释错误 ^ 异或操作 | s[i] | s[j] | re | re^s[i] | re^s[j] || —- |—- | —- | —-|—-|| 0 | 0 | 0 | 0 | 0 || 0 | 1 | 1 | 1 | 0 || 1 | 0 | 1 | 0| 1|| 1 | 1 | 0 |1|1| 对比上面三个操作，我们可以看到，对于s[i] == s[j]，三个操作均没有变换。而对于s[i]!=s[j]： &amp;操作会让1变成0 |操作会让0变成1 ^操作会交换0和1 所以我们可以考虑以下两种情况： 若手链B全为0 或全为1 ，那么怎么操作都不会改变手链B的值，那么由于B!=A，所以手链B不可能变成手链A, 若手链B不全为0或1，那么，我们一次对比手链A和B，看需要改变0的次数和改变1的次数，那么 ans = max(num0,num1),即先用^操作交换两个数，使0，1互换，不够了再一个一个的变换。 时间复杂度为 5.题解代码12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;char a[1000001];char b[1000001];int main(){ int n; scanf("%d",&amp;n); for (int i = 0;i&lt;n;i++){ scanf("%s",a); scanf("%s",b); int len = strlen(a); int num0 =0 ,num1 = 0,num= 0; for (int i = 0;i&lt;len;i++) if(a[i] == '0') num++; if(num == 0 ||num==len){ printf("-1\n"); } else{ for (int i = 0;i&lt;len;i++){ if(a[i]!=b[i]&amp;&amp;a[i] == '0') num0++; else if(a[i]!=b[i]&amp;&amp;a[i] == '1') num1++; } int max = num0&gt;=num1? num0:num1; printf("%d\n",max); } }} F.SkyLee的艾露猫 1. 题目描述众所周知，怪物猎人中的艾露猫是猎人们狩猎时的好伙伴，不仅可以输出，还可以吸引仇恨，甚至还能帮助采集，实在是居家旅行必备之萌物。 艾露猫很可爱，但是寿命只有短短的20年，艾露猫在出生后2年成年，且成年时每对艾露猫都会在年初产下一对小猫，艾露猫成年10年后进入老年，老年持续8年后遗憾地去世。 现在SkyLee得到了一对可爱的艾露猫，他希望艾露猫越多越好，这样打起龙来就很轻松了。假设艾露猫很传统，都是一夫一妻制，并且生出的小猫也正好为一对，若现在为第1年年初，那么第n年SkyLee一共能有多少只可爱的艾露猫呢？ 2. 输入 第一个数为数据组数T 接下来T行，每行1个整数n(保证艾露猫数量不超过int) 3. 输出对于每组数据，输出一行，为第n年艾露猫的数量 4. 解题思路斐波那契自闭 这一题是斐波那契数列的变形题，我们可以分3步讨论 1: 猫不会死也一直会生育，那么 2: 猫不会死但是十年后不会生育，由于猫还需要2年的时间成长，也就是说，12年前的猫不会再生育了，所以 3：猫会死，那么20年前的猫就不在了， 按照这三步来算，将其分为3个阶段，按照程序来写即可 时间复杂度和一般的递推式斐波那契数列一样，均为 5. 题解代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;long long a[1000001];long long b[10001];long long c[10001];using namespace std;int main(){ int n; a[0] =0;a[1] = 2;a[2] = 2; for (int i = 3;i&lt;=60;i++){ if(i&lt;=12) a[i] = a[i-1]+a[i-2]; else a[i] = a[i-1]+a[i-2]-a[i-12]; } scanf("%d",&amp;n); for (int i= 0;i&lt;n;i++){ int y; scanf("%d",&amp;y); if(y&lt;=20) printf("%lld\n",a[y]); else printf("%lld\n",a[y]-a[y-20]); } return 0;} G. SkyLee在GameStop 1. 题目描述SkyLee有一天逛街的时候看到一家新开业的GameStop，里面卖各种各样的游戏。商店里所有的游戏都按游戏名的字典序从小到大排列好了，小的在里面，大的在外面。SkyLee想要把所有的游戏都试玩（买不起游戏只能看看），但是有些问题： 游戏只能从展示架的一侧拿出来 SkyLee只能拿1个游戏试玩 为了不被商店老板发现蹊跷，SkyLee把游戏光盘放回去的时候总要保证每个展示架的游戏仍然按照字典序从小到大排列(小的在里面，大的在外面) SkyLee虽然没钱但是不可能偷游戏，离开时不能拿着游戏 SkyLee发现了两个空的展示架可以放游戏 SkyLee给摆放有游戏的那个展示架编号1，空的编号2和3。假设SkyLee拿游戏、放游戏和试玩游戏都需要时间，现在由你来帮SkyLee提出一个最快的把所有游戏都试玩完的方案吧。 在同样快的试玩方案中，SkyLee会第一时间试玩他拿到的新游戏，然后尽量把字典序更小的游戏放在编号大的展示架上。 2. 输入 多组数据 每组数据1个数n，表示游戏的数量。1≤n≤10 3. 输出对于每组数据，输出把所有游戏都试玩完的最快方案，按以下要求： 拿出游戏输出一行get game from board i，其中i是展示架的编号。 放回游戏输出一行put game to board i，其中i是展示架的编号。 试玩游戏输出一行playing。 离开商场输出一行leave。 4. 解题思路虽然题目比较怪异，但是本质上还是一个Hanoi问题，只不过有一点点的变形。 对于Hanoi 问题，很显然需要用递归来写，首先我们来考虑一下基本情况： 如果只有一个游戏，那么显然 1-&gt; 3 如果有两个游戏，那么根据题目意思，字典序小的要放到标号大的上面，所以在外面的要先放到2号位置，即1-&gt;2,1-&gt;3; 如果超过两个，要在最快的情况下要完成试玩，先将n-2个移到2号位置，第n-1个移到3号，第n个放回本身位置 这题要注意一下，并不需要所以的游戏放到一个位置，所以 放回本身的位置是合法的 两个的时候也是特殊情况，因为可以分开放 时间复杂度为 5. 题解代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;void move(char from, char to){ printf("get game from board %c\n", from); printf("playing\n"); printf("put game to board %c\n", to);}void moves(char from, char to){ printf("get game from board %c\n", from); printf("put game to board %c\n", to);}void hanoi2(int n, char from, char depend, char to){ if (n == 1) moves(from, to); else{ hanoi2(n - 1, from, to, depend); moves(from, to); hanoi2(n - 1, depend, from, to); }}void hanoi(int n, char from, char depend, char to){ if (n == 1) move(from, to); else{ hanoi(n - 1, from, to, depend); move(from, to); hanoi2(n - 1, depend, from, to); }}int main(){ char a = '1', b = '2', c = '3'; int n; while (cin &gt;&gt; n){ if (n &gt; 2){ hanoi(n - 2, a, c, b); move(a, c); move(a, a); printf("leave\n"); } else if (n == 2){ move(a, b); move(a, c); printf("leave\n"); } else{ move(a, c); printf("leave\n"); } }} H .序列优美差值 1. 题目描述给定一个序列a，询问满足i&lt;j且 L≤a[j]−a[i]≤R的点对（i,j）数量 2. 输入 第一个数为数据组数T，每组数据两行。 第一行为整数n, L, R，表示序列长度，L，R； 接下来一行为空格分隔的n个整数。 T≤10 . n≤1e6 3. 输出对于每组数据，输出一行，点对的数量 4. 解题思路对于求数组中前后元素关系的题，通常而言我们有两种方法： 暴力求解。既然是比大小，那我们只要一个二重循环，将整个数组遍历一遍，记录满足条件的值即可。时间复杂度为 分治法。利用归并排序，在排序的时候利用数组间已经有的大小关系，来算出我们需要的解。时间复杂度为 通常第一种情况比较好写算法，然而时间复杂度过高，所以我们不考虑。 我们来看看第二种算法：考虑两个有序数组L,R,对于它们之间的答案，可分为三部分： L数组中满足条件的对数 R数组中满足条件的对数 L和R数组之间满足条件的对数 可以想到，对于1和2这两部分的答案，在归并的上一次二分时便可得出答案，那么，我们每一次便只需要考虑数组间的对数即可. 5.题解代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;typedef long long ll;int n,l,r;const int N= 1000010;ll a[N],k[N],ans;void Merge(int left,int right){ if(left &gt;= right) return ; int mid = (left+right)/2; Merge( left, mid); Merge( mid+1, right); int s = left,e = left; for (int i = mid+1;i&lt;=right;i++){ while(a[i] - a[e]&gt;=l&amp;&amp;e&lt;=mid) ++e; while(a[i] - a[s]&gt;r&amp;&amp;s&lt;=mid) ++s; ans += e - s; } int i = left,j = mid+1,p = left; while(i&lt;=mid&amp;&amp;j&lt;=right) k[p++] = a[i]&lt;a[j]? a[i++]:a[j++]; while(i&lt;=mid) k[p++] = a[i++]; while(j&lt;=right) k[p++] = a[j++]; for (int i = left;i&lt;=right;i++) a[i] = k[i];}int main(){ int T; scanf("%d",&amp;T); for (int i = 0;i&lt;T;i++){ ans = 0; scanf("%d %d %d",&amp;n,&amp;l,&amp;r); for (int j = 0;j&lt;n;j++){ scanf("%lld",&amp;a[j]); } Merge(0, n-1); printf("%lld\n",ans); } return 0;}]]></content>
      <categories>
        <category>算法上机</category>
      </categories>
      <tags>
        <tag>算法上机</tag>
        <tag>北航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题优化，打造个人精致网站]]></title>
    <url>%2Fhexo-next-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[写在前面 关于个人博客，其实自己很早之前就有了这个打算，然而因为种种的原因（其实就是自己懒），自己一直没有把自己的博客真正的上线，自从四月份写了第一篇blog后就没有碰过了。直到暑假的时候，闲来无事了解算法，观摩了各路大神的blog，才发现，woc，他们的blog怎么这么好看。回想自己大一的一年，貌似自己在这一年内也没有留下些什么，so趁着假期还有时间，将自己荒废已久的blog又拿了出来。 回到正题，既然决定要搭建个人blog，界面ugly怎么行？常言道： 生活还是精致一点的好. –佚名 so经过不断的优化，博主的blog也终于有了一点小起色，才有了现在的界面，个人感觉还是挺ok的。然而，在布置界面的时候，深受网上来来去去搜索的痛苦，所以在这里，本人做一个小结。不敢说能把各位的blog布置的有多好看，但至少，达到我这个程度还是可以的。 1. blog配置 常言道： 任何不谈配置只谈操作的行为都是在耍流氓 –佚名 虽说hexo的版本3.x之间改动也不是很大，next5.x系列和现在的6.x系列也差不多，但是终归还是有那么一点细小的变化，保不准就会有bug生成，所以博主还是提一下自己的blog配置：1Hexo v3.7.1 Next v6.3.0 编辑器：sublime text2 就目前为止，已经算是挺新版的了，当然，大多数配置各版本之间都一样，大家可以酌情考虑版本的选择。 好了！准备进入正题！本blog将带领各位怎么将一个空空如也的blog装饰成博主一样有那么一点起色的网站。博主将从零搭起，所有的操作都将在博主的笔记本上为大家做出示范。 1.1 next主题基本配置首先我们先下载next主题:在这里选择大家需要的版本进行下载。下载完成后，我们的blog便有了两个主要的配置文件，分别是hexo自带的_config.yml文件和next主题自带的_config.yml文件，为了方便，我们将hexo自带的_config.yml文件称为站点配置文件，next主题带的_config.yml文件称为主题配置文件。 首先，第一步我们来更换一下blog的主题，这一步又分为三个小步骤： 将下载下来的next主题文件夹重命名为 next 。 将next文件夹移入blog所在的文件夹的themes 文件夹中，在这里，本人是/blog/themes 修改站点配置文件，在配置文件中搜索theme，将其的值改为next。注意 冒号： 后面一定要有一个空格// 站点_config.yml 文件1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 现在主题就已经配置好了，接下来我们优化一下：继续修改站点配置文件：// 站点_config.yml 文件12345678# Sitetitle: Eternal_zttz #网站的名字subtitle: Saty Hungry，Stay Foolish #网站的副标题description: 个人blog网站 #个人的描述keywords:author: Eternal_zttz #博主的名字language: zh-CN #blog的语言 zh-CN 代表中文timezone: 然后我们修改主题配置文件：// 主题_config.yml 文件 ，搜索Schemes可找到12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 这是next的基本页面布局，默认为Muse布局，在这里，我们选择第三个Pisces 很好，接下来，我们在终端命令行cd 进入blog所在目录，如我是直接命名为blog，所以cd blog: 接着运行： 1hexo s 在浏览器中打开链接：不出意外，打开后会是这么样的界面：ok，我们的blog已经略有起色，样式已经离我们的最终样式八九不离十了，接下来，我们将对其的各个部分进行优化： 2. next主题侧边栏优化在这一部分，我们将对next主题的侧边栏进行优化，主要分为以下几部分： next主题页面生成 个人头像设置 点击个人头像回到主页面 RSS订阅设置 社交栏图标的设置 添加网易云音乐 页面圆角的设置 2.1. next主题页面生成我们可以看到，hexo默认生成的页面只有两个，即首页和归档 页面，对于有强迫症的我来说简直是不！ 协！ ！调，那么接下来，我们来生成我们所需的页面： 2.1.1 页面的生成：首先，我们修改主题配置文件：// 主题_config.yml 文件 ，搜索menu可找到123456789menu: home: / || home #主页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #日程表 #sitemap: /sitemap.xml || sitemap #站点地图 #commonweal: /404/ || heartbeat #公益404 可以看到，大部分的都是注释掉了的，这里我已经把我需要的页面注释解除了，大家可以自行考虑需要的页面。在这里，斜线//之间的文字是 该页面 的名字，如／about／ ，说明我们要跳转的页面的名字为about , 而||后的文字是这个页面的图标名字.这时候我们主页上就可以看到这几个页面，接下来实现页面的跳转： 2.1.2 生成about页面：终端回到blog的根目录.运行：1hexo new page "about" ok,接下来关于页面的markdown自己编写就行。 2.1.3 生成tags页面：终端回到blog的根目录.运行：1hexo new page "tags" 2.1.4 生成categories页面:终端回到categories的根目录.运行：1hexo new page "categories" tags和categorise页面不用自己布局，会自动根据我们的blog的布局好 2.2 站内搜索功能的实现文章写多了，想一篇篇的去寻找可不容易，这时候，我们便需要一个站内的搜索功能，即服务别人，也能方便自己。首先，我们在终端进入blog的根目录下，执行以下命令：1$ npm install hexo-generator-searchdb --save 接着，我们进入站点配置文件_config.yml,在最后新增以下内容：12345search: path: search.xml field: post format: html limit: 10000 最后，打开主题配置文件_config.yml,搜索local_search,其值改为true：123# Local searchlocal_search: enable: true ok，现在站内搜索就大功告成了，一切准备就绪～ 2.3 个人头像设置要设置自己的侧边栏头像，首先，准备一张头像的图片，命名为header.jpg，然后，将图片放在/blog/themes/next/source/images/文件夹下，接着修改主题配置文件，搜索avatar123456789101112avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. - url: /images/avatar.gif + url: /images/header.jpg #图片的地址 # If true, the avatar would be dispalyed in circle. rounded: false #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 #图片的透明度 # If true, the avatar would be rotated with the cursor. rotated: false #设置鼠标移到图片上后头像是否转动 将url里面的值改为图片的地址就可以了， 2.4 点击个人头像回到主页面一般我们看到一个头像，总忍不住去点击它，然而遗憾的是，next主题中默认并没有这个事件，作为一个强迫症，这能忍？？？其实，实现这个功能也很简单：首先，我们打开文件/blog/themes/next/layout/_macro/sidebar.swig,然后，修改以下内容：12345+ &lt;a href="/"&gt; &lt;img class="site-author-image" itemprop="image" src="{{ url_for( theme.avatar.url | default(theme.images + '/avatar.gif') ) }}" alt="{{ author }}" /&gt;+ &lt;/a&gt; ok，重新部署一下，就可以看到效果了 2.5 RSS订阅设置什么？大家都不知道什么是RSS？！！！好吧，其实…本博主也不知道emmm，大家可以看看知乎上有关RSS的文章PS：加上好看就完事了不是,计较干啥首先，我们在终端命令行进入blog所在的目录，运行：1$ npm install --save hexo-generator-feed 接着，打开站点配置文件，在文件的末尾添加：123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开主题配置文件，搜索rss，将其设置成如下所示，注意冒号后要加上一个空格1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: /atom.xml OK，all right 2.6 社交栏设置在主题配置文件中，搜索social，定位到如下代码段，把social的注释取消掉，接下来，就看你需要显示什么社交网站，写上网站名+网址就行。123456789101112social: GitHub: https://github.com/yourname || github #网站名：网址 ||图标名 简书: http://www.jianshu.com || heartbeat #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 2.7 增加网易云音乐音乐是不应该被辜负的，所以，我们可以在侧边栏加上网易云的音乐外链，具体方法为： 打开网易云音乐网页版，选择自己想要放上去的音乐。 在播放页面选择外链播放器，选择一个自己喜欢的样式。 复制其中的代码 打开/blog/themes/next/layout/_macro/sidebar.swig 文件，将代码复制到适合的位置，例如，我是在约161-162行增加1234567891011{% endif %} {% include custom_sidebar %} &lt;/div&gt; &lt;/section&gt; + &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&amp;id=5079881&amp;auto=0&amp;height=32"&gt;&lt;/iframe&gt; {% if display_toc and toc(page.content).length &gt; 1 %} &lt;!--noindex--&gt; &lt;section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"&gt; &lt;div class="post-toc"&gt; 重新部署一下网站，就可以看到结果了 2.8 实现侧边栏页面的圆角侧边栏默认是矩形的，可能有一些朋友不是特别喜欢这种尖锐的四角，希望可以稍稍弄的平滑一点，说干就干！下面我们来具体实现它。 首先，我们打开/blog/themes/next/source/css/_variables/Pisces.styl文件，里面定义了一些常量，用来定义blog样式表的值。 然后，找到$border-radius，1234567// Borders// --------------------------------------------------$box-shadow-inner = initial;$box-shadow = initial;$border-radius-inner = initial;$border-radius = initial; 可以看到默认为初始值，即为0改变 为$border-radius = 16px;这时候，下面的一个侧边栏弧度就已经改好了 接着，打开/blog/themes/next/source/css/_schemes/Pisces/_layout.styl文件，diff:true12345678910.header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: $sidebar-desktop; background: white; box-shadow: $box-shadow-inner; -border-radius: $border-radius-inner; +border-radius: $border-radius;//修改上面的侧边栏的弧度 12345678910.content-wrap { float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: white; min-height: 700px; box-shadow: $box-shadow-inner; - border-radius: $border-radius-inner; + border-radius: $border-radius; //修改整个文章页面的弧度 ok 大功告成，到此为止，我们文章的侧边栏就已经优化完毕了，当然，还有更多操作，大家可以去尝试，不过，建议没有把握之前先做好blog的备份。别问我为什么要这么说来看看最终侧边栏效果： 3. next主题主页面优化在上面我们已经把侧边栏的优化都已经完成了，不得不说，刚完成这一部分时我还是有很大的成就感的，接下来，我们将对我们blog的主页面进行进一步的优化。在这一部分，我们将对以下进行操作： blog右上角出现fork me on github 图标 文章背景出现阴影边框 为文章内容添加统计功能，文字总数+阅读时长 为文章中的代码块增加一键复制功能 文章结尾出现“本文结束提示” 增加打赏功能 增加版权信息 修改标签样式 3.1 增加fork me on github 图标在这里(图片版)或这里(文字版)选择一款自己喜欢的图标，然后把图标旁的代码拷贝一份，放到1blog/themes/next/layout/_layout.swig 这个文件夹中，注意要放到&lt;div class="headband"&gt;&lt;/div&gt;的下方OK,这就大功告成了。 3.2 文章背景出现阴影边框这个效果实现起来很简单，打开blog\themes\next\source\css\_custom\custom.styl文件，放入以下代码：12345678// 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 重新部署一下即可实现。 3.3 实现点击出现爱心功能首先，进入该网址,复制页面中的代码，在路径blog/themes/next/source/js/src/中新建love.js文件，将复制的代码粘贴到该文件中。然后打开/blog/themes/next/layout/_layout.swig文件，在该文件的最后增加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 保存后即可看到效果。 3.4 “ 阅读全文 ” 按钮改弧度这个功能和侧边栏改弧度的操作是差不多的，进入文件/blog/themes/next/source/css/_variables/Pisces.styl中，把以下代码修改一下：12345678// Button- $btn-default-radius = 2px+ $btn-default-radius = 16px$btn-default-bg = white$btn-default-color = $text-color$btn-default-border-color = $text-color$btn-default-hover-color = white$btn-default-hover-bg = $black-deep 保存后即可看见效果。 3.5 为文章内容添加统计功能，文字总数+阅读时长这个功能在next主题中已经存在了，我们只需要打开开关就行，具体步骤分为下面三步： 终端进入blog根目录，执行下面代码： 1$ npm install hexo-symbols-count-time --save 进入站点配置文件，为blog配置统计功能，将以下代码复制到最后： 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 进入主题配置文件，搜素symbols_count_time,然后把要显示的改为true.更深入的操作大家可以看github上的说明。PS：如果大家配置完成，然后检查无误后，打开页面依旧没有显示，不要着急，第一次显示可能会比较慢，可以休息一会。（本人多次从头配置都没有效果，一气之下去睡了个午觉，醒来就好了0.0）. 3.6 为文章中的代码块增加一键复制功能在next v6.3.0 版本中，这个功能已经是集成了的，我们进入站点配置文件，搜索copy_button。把它的值改为true即可：12345# Add copy button on codeblock copy_button:copy enable: true #是否开启复制功能 # Show text copy result show_result: true #是否显示提示的复制结果 接着，将鼠标移动到代码块中，便可以看到结果。默认按钮是中文“复制”，若是想改为英文“copy”，可进入blog/themes/next/languages/zh-CN.yml文件中，将下面部分改了即可：12345copy_button: copycopy_success: succeedcopy_failure: failedcopyright: author: 本文作者 这个文件夹中保留了所有的中英部分的对应关系，大家想改各标签名字的话，可以将这个文件中对应的部分改了即可。 3.7 文章结尾提示 “本文结束”在文件夹\themes\next\layout\_macro中新建passage-end-tag.swig文件，并在文件中增加以下代码：12345&lt;div&gt; {% if not is_index %} &lt;div style="text-align:center;color: #555;font-size:14px;"&gt;-------------The End-------------&lt;/div&gt; {% endif %}&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，再这个地方增加如下代码：123456789101112131415 {#####################} {### END POST BODY ###} {#####################}+ &lt;div&gt;+ {% if not is_index %}+ {% include 'passage-end-tag.swig' %}+ {% endif %}+ &lt;/div&gt; {% if theme.wechat_subscriber.enabled and not is_index %} &lt;div&gt; {% include 'wechat-subscriber.swig' %} &lt;/div&gt; {% endif %} 代码如下：12345&lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 最后打开主题配置文件，在文件的最后增加如下代码：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 保存后，打开网页即可看到效果。 3.8 增加打赏功能这个功能很简单，首先，我们将保存微信支付的收款码，将其命名为wechatpay.jpg，并将其保存在/blog/themes/next/source/images/文件中。接着，我们打开主题配置文件，搜索wechatpay，将其前面的注释取消即可：12345#Reward#reward_comment: Donate comment herewechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png 这里我们可以放多种方式的支付码，看个人喜好即可，方法都是一样的。 3.9 增加版权信息博文写好了，怎么说也是作者的一番心血，我们不去抄袭别人的作品，也不希望别人什么都不说带走我们的作品，所以，我们需要在底部做一个版权申明：next主题中现在已经是集成了这个功能的了，我们只在主题配置文件中搜索copyright,并把enable的值改为true即可. 3.10 修改标签样式默认的标签前面是一个#号，我们把它改成标签的符号：修改模板/themes/next/layout/\_macro/post.swig，搜索rel="tag"&gt;#，将# 换成&lt;i class="fa fa-tag"&gt;&lt;/i&gt;即可。 这时候，我们的标签还是有下划线的，要想去掉下滑线，我们可以进入： 1/blog/themes/next/source/css/_custom/custom.styl 文件，在文件最后增加下面代码：123.posts-expand .post-tags a { border-bottom: none;} 即可 4. next主题底部优化侧边栏和主页面的优化都已经实现了，接下来便是底部部分的优化，主要包括下面几个部分： 为文章增加评论功能 增加在线联系Daovoice 修改底部作者图标为跳动的红心 隐藏下方的强力驱动和主题信息 增加本站运行时间 增加站点访问人数和总访问量 4.1 为文章增加评论功能next主题的6.x版里面已经集成了很多评论了，包括Gitment和Valine，大家有兴趣可以去试一试。最开始我用的评论是来必力评论系统， 4.2 增加在线联系Daovoice首先在Daovoice注册账号,邀请码是5f353066，注册完成后会得到一个 app_id声明：这个链接包含了博主的邀请码，注册成功每人会有100元代金券，如果不想使用，可以进入Daovoice官网注册账号。注册成功后，会得到一个app_id:1234daovoice('init', { app_id: "*******"});daovoice('update'); 记下这个app_id的值，然后打开/blog/themes/next/layout/_partials/head/head.swig文件，在如下位置插入代码：123456789{% if theme.daovoice %} &lt;script&gt; (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', { app_id: "{{theme.daovoice_app_id}}" }); daovoice('update'); &lt;/script&gt;{% endif %} 接着打开主题配置文件，在最后写下如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 保存后打开页面即可看见效果。 4.3 修改底部作者图标为跳动的红心这个功能实现起来很简单，打开主题配置文件,搜索animated:把icon 区域的代码做如下修改：123456789# Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 保存即可，如果想改为其他的图标，进入网站修改即可 4.4 隐藏下方的强力驱动和主题信息进入/blog/themes/next/layout/_partials/footer.swig文件，注释掉关于这部分的信息即可：1234567891011121314151617181920{% if theme.footer.powered.enable %} + &lt;!-- &lt;div class="powered-by"&gt;{# #}{{ __('footer.powered', '&lt;a class="theme-link" target="_blank"' + nofollow + ' href="https://hexo.io"&gt;Hexo&lt;/a&gt;') }}{% if theme.footer.powered.version %} v{{ hexo_env('version') }}{% endif %}{##}&lt;/div&gt;{% endif %}{% if theme.footer.powered.enable and theme.footer.theme.enable %} &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;{% endif %}{% if theme.footer.theme.enable %} &lt;div class="theme-info"&gt;{# #}{{ __('footer.theme') }} &amp;mdash; {# #}&lt;a class="theme-link" target="_blank"{{ nofollow }} href="https://github.com/theme-next/hexo-theme-next"&gt;{# #}NexT.{{ theme.scheme }}{# #}&lt;/a&gt;{% if theme.footer.theme.version %} v{{ version }}{% endif %}{##}&lt;/div&gt;+ --&gt;{% endif %} 4.5 增加本站运行时间进入/blog/themes/next/layout/_partials/footer.swig文件，在文件合适的地方放上如下代码：1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt;&lt;script&gt;function show_date_time(){ window.setTimeout("show_date_time()", 1000); BirthDay=new Date("04/17/2018 15:13:14");//修改为自己的blog建站时间 today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}function setzero(i){ if (i&lt;10) {i="0" + i}; return i;}show_date_time();&lt;/script&gt; 如我是在原next主题版本信息的下方增加上面的代码，代码在不同的位置会有不同的效果。 4.6 增加站点访问人数和总访问量打开主题配置文件，搜索busuanzi，将enable的值改为true即可。12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 5. 推荐大佬文章这篇文章主要是为了记录自己搭建blog的经历，因为搭建blog的时候，自己经常忘记优化的方法，特记下以减轻今后搜索的负担：网上有很多特别详细的优化文章，本篇文章也参考了很多，特拿出来与大家分享： hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 强烈推荐最后一篇blog，一路看下来会收获很多很多]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo折腾记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hanoi 问题]]></title>
    <url>%2FHanoi-%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[一：有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆： 每次只能移动一个圆盘； 大盘不能叠在小盘上面。请输出全部的移动操作。 输入：一个整数n，表示汉诺塔的层数(n &lt; 20)输出：输出把汉诺塔从A移到C的全部操作，每个操作一行 12345678910111213141516#include &lt;cstdio&gt;void Move(int n,char a,char b,char c){ if(n == 1) printf("%c -&gt; %c\n",a,c); else{ Move(n-1,a,c,b); printf("%c -&gt; %c\n",a,c); Move(n-1,b,a,c); }}int main(){ int n; scanf("%d",&amp;n); Move(n,'A','B','C'); return 0;} 输入：13 输出：1234567A -&gt; CA -&gt; BC -&gt; BA -&gt; CB -&gt; AB -&gt; CA -&gt; C 二：还是汉诺塔，但是现在的汉诺塔只能在相邻的柱子间移动（A只能移动到B; B只能移动到A或C; C只能移动到B）。在整个移动过程中，任何时候都保证小盘子只能在大盘子上面。还是给定层数数n，你需要输出把所有盘从A移到C的操作。输入：多组数据输入。第一行是输入数据组数T(0&lt;T&lt;11)。接下来T行，每行一个整数n(0&lt;n&lt;20)，代表层数(盘子个数)。输出：对于每组数据输出其对应的操作，每组数据间用一个空行隔开123456789101112131415161718192021222324#include &lt;cstdio&gt;void Move(int n,char a,char b,char c){ if(n == 1){ printf("%c -&gt; %c\n",a,b); printf("%c -&gt; %c\n",b,c); } else{ Move(n-1,a,b,c); printf("%c -&gt; %c\n",a,b); Move(n-1, c, b, a); printf("%c -&gt; %c\n",b,c); Move(n-1, a, b, c); }}int main(){ int n,t; scanf("%d",&amp;t); for (int i =0;i&lt;t;i++){ scanf("%d",&amp;n); Move(n, 'A', 'B', 'C'); printf("\n"); } return 0;} 运行结果：123456789101112131421A -&gt; BB -&gt; C2A -&gt; BB -&gt; CA -&gt; BC -&gt; BB -&gt; AB -&gt; CA -&gt; BB -&gt; C]]></content>
      <categories>
        <category>算法</category>
        <category>Hanoi</category>
      </categories>
      <tags>
        <tag>算法学习日历</tag>
        <tag>Hanoi</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法堆优化]]></title>
    <url>%2FDijkstra%E7%AE%97%E6%B3%95%E5%A0%86%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[利用堆来优化普通的Dijkstra算法，能达到更快的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define INF 9999999999999typedef long long ll;typedef struct Edge{ int u,v,w,nxt;}edge;edge e[500010];int head[100010];int cnt = 0;void addedge(int u,int v,int w){ e[++cnt] = {u,v,w,head[u]}; head[u] = cnt;}int n,m,s;ll dis[100010];struct node{ ll u,d; bool operator &lt;(const node&amp;rhs)const{ return d&gt;rhs.d; }};void dijkstra(){ for (int i =1;i&lt;=n;i++) dis[i] = INF; dis[s] = 0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node flag = q.top(); q.pop(); ll u = flag.u,d = flag.d; if(d!=dis[u]) continue; for (int i = head[u];i;i=e[i].nxt){ int v = e[i].v,w = e[i].w; if(dis[v]&gt;dis[u]+w){ dis[v] = dis[u]+w; q.push((node){v,dis[v]}); } } }}int main(){ while(~scanf("%d %d ",&amp;n,&amp;m)){ for (int i = 1;i&lt;=m;i++){ int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); } s = 1; dijkstra(); for (int i = 1;i&lt;=n;i++){ if(dis[i] == INF) printf("-1 "); else printf("%lld ",dis[i]); } printf("\n"); } return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法记录最短路径]]></title>
    <url>%2FDijkstra%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[用dijkstra算法来记录最短路径方法，用一个数组path[]记录前驱顶点，找到最短路后，从终点倒向追踪，直到找到起点为止。这里可以利用栈来记录路径倒推的过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;#define N 1001#define M 50001#define INF 99999999int n,m,s,t1,t2,t3;;int dis[N],tim[N];bool vis[N];int e[N][N];int pre[N];void dijkstra(){ for (int i = 1;i&lt;=n;i++){ dis[i] = e[s][i]; vis[i] = false; pre[i] = dis[i]!=INF&amp;&amp;i!= s? s:-1; } vis[s] = true; int u =1; for (int i =1;i&lt;=n;i++){ int min = INF; for (int j =1;j&lt;=n;j++){ if(!vis[j]&amp;&amp;dis[j]&lt;min){ min = dis[j]; u = j; } } vis[u] = true; for (int v = 1;v&lt;=n;v++){ if(e[u][v]&lt;INF){ if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v]){ dis[v] = dis[u] +e[u][v]; pre[v] = u; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); if(n ==00&amp;&amp;m==0) return 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) e[i][j] = i==j? 0:INF; } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } int start ,end; while(~scanf("%d %d",&amp;start,&amp;end)){ s = start; dijkstra(); if(start == end){ printf("从%d到%d的最短路径是：%d\n",start,end,start); printf("最短路径：%d\n",0); }else{ stack&lt;int&gt; path; path.push(end); int now = pre[end]; while(1){ path.push(now); if(now == start) break; now = pre[now]; } printf("从%d到%d的最短路线是：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",dis[end]); } }} 程序输入：123456789104 81 2 21 3 61 4 42 3 33 1 73 4 14 1 54 3 124 3 程序输出：12从4到3的最短路线是：4--&gt;1--&gt;2--&gt;3最短路径：10]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法求解最短路问题]]></title>
    <url>%2FDijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[Dijkstra算法思路：Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 1001#define M 50001#define INF 99999999int n,m,s,t1,t2,t3;;int dis[N],tim[N];bool vis[N];int e[N][N];void dijkstra(){ for (int i = 1;i&lt;=n;i++){ dis[i] = e[s][i]; vis[i] = false; } vis[s] = true; int u =1; for (int i =1;i&lt;=n;i++){ int min = INF; for (int j =1;j&lt;=n;j++){ if(!vis[j]&amp;&amp;dis[j]&lt;min){ min = dis[j]; u = j; } } vis[u] = true; for (int v = 1;v&lt;=n;v++){ if(e[u][v]&lt;INF){ if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v]){ dis[v] = dis[u] +e[u][v]; } } } }}int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;s); if(n ==00&amp;&amp;m==0) return 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) e[i][j] = i==j? 0:INF; } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } dijkstra(); for (int i = 1;i&lt;=n;i++) printf("%d ",dis[i]); }]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA算法记录最短路径]]></title>
    <url>%2FSPFA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[路径记录方法：用path[]数组依次记录前驱节点，当找到最短路后，由终点倒推，直到找到起点，可以利用一个栈来维护此过程。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 999999999using namespace std;struct node { int u,v,w,next;};int head[N],len[N],pre[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ edge[cnt] = {u,v,w,head[u]}; head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; pre[v] = u;//记录v的前驱节点为u if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); node edge[m+1]; cnt = 1; memset(head, 0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); memset(pre,-1,sizeof(pre)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); //add(edge,v,u,w); } int start,end; while(~scanf("%d %d",&amp;start,&amp;end)){ s = start; SPFA(q, edge); if(start == end){ printf("从%d 到%d的最短路线：%d\n",start,end,start); printf("最短路径：%d",0); }else{ stack&lt;int&gt; path; path.push(end); int now = pre[end];//now 为end的前驱节点，即倒数第二个节点 while(1){ path.push(now); if(now == start)//找到起点，退出 break; now = pre[now];//依次寻找上一个节点的前驱节点 } printf("从%d到%d的最短路线：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",len[end]); } }}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA算法求解最短路问题]]></title>
    <url>%2FSPFA%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[SPFA算法实现方法：建立一个队列，初始时队列中只有起始点，用一个数组记录起始点A到其他所有点之间的距离（初始时自身为0，其余为INF),然后利用该点A对与该点直接相通的点Bi进行松弛操作，如果操作成功，而被Bi未在队列中，那么Bi入队。A出队，然后对队列中的下一个元素做相同的操作，直到队列为空，此时数组中的值便是起始点与其余点之间的最短路径。SPFA算法可判断是否存在负权环路，判断方法是检查是否存在一个点进入队列N次。算法复杂度为O(KE).1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define M 1000005#define N 100005#define INF 99999999using namespace std;struct node { int u,v,w,next;};int head[N],len[N];bool vis[N];int n,m,cnt,s = 1;void add(node edge[],int u,int v,int w){ /* edge[cnt].u =u; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; */ edge[cnt]={u,v,w,head[u]};//这一句相当于上面四句 head[u] = cnt++;}void SPFA(queue&lt;int&gt;q,node edge[]){ q.push(s); vis[s] = true; for (int i=1;i&lt;=n;i++) len[i] = INF; len[s] = 0; while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u];i&gt;0;i=edge[i].next){ int v = edge[i].v; int w = edge[i].w; if(len[v]&gt; len[u]+w){ len[v] =len[u]+w; if(!vis[v]){ vis[v] =true; q.push(v); } } } }}int main(){ while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;s)){//n为顶点数，m为边数，s为起始点 node edge[m+1]; cnt = 1; memset(head,0, sizeof(head)); memset(len,0,sizeof(len)); memset(vis,false,sizeof(vis)); queue&lt;int&gt;q; for (int i =1;i&lt;=m;i++){ int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(edge,u,v,w); //add(edge,v,u,w);如果是无向图，则加上这一句，注意加上后edge数组的范围应扩大一倍 } SPFA(q, edge); for (int i =1;i&lt;=n;i++){ printf("%d ",len[i]); } printf("\n"); }}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法记录路径]]></title>
    <url>%2FFloyd%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84.html</url>
    <content type="text"><![CDATA[关于Floyd算法记录路径的方法一般有两种：一是用path[i][j]记录i的后继节点，二是用path[i][j]记录j的前驱节点。第一种方法：利用path[i][j]记录i的后继节点。路径记录关键代码：1: 初始化：1path[i][j] = j; 2:路径转移记录：1path[i][j] = path[i][k]; 完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define INF 10000001int e[1001][1001];int path[1001][1001];int n,m,t1,t2,t3;void init(){ //初始化e,path数组 memset(e,0,sizeof(e)); memset(path,0,sizeof(path)); for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(i == j) e[i][j] = 0; else e[i][j] = INF; path[i][j] = j; } } //输入边 for (int i =1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; }}void Floyd(){ //floyd算法 for (int k =1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]){ e[i][j]=e[i][k]+e[k][j]; path[i][j] = path[i][k]; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); init(); Floyd(); int start,end; //得出从start 到end 的路径 while(~scanf("%d %d",&amp;start,&amp;end)){ if(start == end){ printf("从%d到%d的最优路线 : %d\n",start,end,start); printf("最短路径：%d\n",0); } else{ printf("从%d到%d的最短路线：%d",start,end,start); int now= path[start][end]; while(1){ printf("--&gt;%d",now); if(now == end) break; now = path[now][end]; } printf("\n"); printf("最短路径：%d\n",e[start][end]); } } return 0;} 第二种方法：利用path[i][j]记录j的前驱节点,这个方法需要利用stack来输出路径路径记录关键代码：1:初始化：1pre[i][j] = i; 2:路径转移记录：1pre[i][j] = pre[k][j]; 完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define INF 10000001using namespace std;int e[1001][1001];int pre[1001][1001];int n,m,t1,t2,t3;void init(){ memset(e,0,sizeof(e)); memset(pre, 0, sizeof(pre)); for (int i =1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ e[i][j] = i==j? 0:INF; pre[i][j] = i; } } for (int i = 1;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); if(e[t1][t2]&gt;t3) e[t1][t2] = t3; }}void Floyd(){ for (int k =1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j =1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]){ e[i][j] = e[i][k]+e[k][j]; pre[i][j] = pre[k][j]; } } } }}int main(){ scanf("%d %d",&amp;n,&amp;m); init(); Floyd(); int start,end; while(~scanf("%d %d",&amp;start,&amp;end)){ if(start == end){ printf("从 %d 到 %d 的最短路线：%d\n",start,end,start); printf("最短路径:%d\n",0); }else{ int now = pre[start][end]; stack&lt;int&gt;path; path.push(end); while(1){ path.push(now); if(now == start) break; now = pre[start][now]; } printf("从 %d 到 %d 的最短路线：%d",start,end,start); path.pop(); while(!path.empty()){ printf("--&gt;%d",path.top()); path.pop(); } printf("\n"); printf("最短路径：%d\n",e[start][end]); } } return 0;}]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[floyd最短路算法]]></title>
    <url>%2Ffloyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[Floyd算法是一种动态规划算法，适用于多源最短路径，相对于Dijkstra算法和SPFA算法，其算法复杂度较高，时间复杂度为O(n^3),但其理解较为容易，且代码简单。其基本思想便是对点松弛，在任意 i,j 顶点中，看是否存在顶底k,使得i -&gt; k -&gt; j 的距离小于i -&gt; j的距离，如果存在，则对该两点进行松弛操作。核心代码：12345678for (int k = 1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j] = e[i][k]+e[k][j]; } } } 完整代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int e[1000][1000];int main(){ int n,m,t1,t2,t3; int inf = 9999999; scanf("%d %d",&amp;n,&amp;m); for (int i = 1;i&lt;=n;i++) for (int j =1 ;j&lt;=n;j++){ if(i == j) e[i][j] = 0; else e[i][j] = inf; } for (int i =1 ;i&lt;=m;i++){ scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); //这里if主要是为了在存在多条从t1到t2的路径时，记录最短的一条 if(e[t1][t2]&gt;t3) e[t1][t2] = t3; } for (int k = 1;k&lt;=n;k++){ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j] = e[i][k]+e[k][j]; } } } for (int i =1 ;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++) printf("%d ",e[i][j]); printf("\n"); } return 0;} 测试数据：1234567894 81 2 21 3 61 4 42 3 33 1 73 4 14 1 54 3 12 输出：12340 2 5 4 9 0 3 4 6 8 0 1 5 7 10 0]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言快速排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[快速排序；基本思路： 从当前参加排序的元素中任选一个元素作为分界元素，与当前参加排序的那些元素进行比较. 凡是小于分界元素的元素都移到分界元素的前面,凡是大于分界元的元素都移到分界元素的后面。 分界元素将当前参加排序的元素分成前后两部分,而分界元素处在排序的最终位置。 然后，分别对这两部分中大小大于1的部分重复上述过程直到排序结束时间复杂度为：O(nlogn) 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}void quicksort(int a[],int left,int right){ if(left&gt;=right) return ; int key = a[left]; int i = left,j = right; while(i&lt;j){ while(i&lt;j&amp;&amp;a[j]&gt;=key) j--; a[i] = a[j]; while(i&lt;j&amp;&amp;a[i]&lt;=key) i++; a[j] = a[i]; } a[i] =key; quicksort(a, left, i-1); quicksort(a, i+1, right);}int main(){ int n; while(~scanf("%d",&amp;n)){ int num[n]; for (int i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); quicksort(num,0,n-1); for (int i = 0;i&lt;n;i++) printf("%d ",num[i]); printf("\n"); }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言堆排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[堆排序：堆排序可以看成优化版的选择排序 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了其算法时间复杂度为O(nlogn) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a = b;b = t;}void adjust(int a[],int i,int n);void heapSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); heapSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void adjust(int a[],int i,int n){ int j,temp; temp = a[i]; j = 2*i+1; while(j&lt;n){ if(j+1&lt;n&amp;&amp;a[j]&lt;a[j+1]) j++; if(temp&lt;a[j]){ a[(j-1)/2] = a[j]; j = 2*j+1; } else break; } a[(j-1)/2] = temp;}void heapSort(int a[],int n){ int i; for (i = n/2-1;i&gt;=0;i--) adjust(a,i,n); for (i = n-1;i&gt;=1;i--){ SWAP(a[0],a[i]); adjust(a,0,i); }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言冒泡排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[冒泡排序是一种简单的排序算法 ，其基本思路如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。其算法时间复杂度为O(n^2). 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}//宏定义交换过程void bubbleSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); bubbleSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void bubbleSort(int a[],int n){ int i,j; int flag = 0; for (i =0 ;i&lt;n;i++){ flag = 0; for (j = 0;j&lt;n-1-i;j++){ if(a[j]&gt;a[j+1]){ SWAP(a[j], a[j+1]); flag=1; } } if(flag == 0) break;//如果某一趟排序没有进行交换，说明排序已经结束，可以略微提高排序的效率 }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言选择排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[选择排序是基本排序算法之一，其基本思路为： 初始时选择整个序列中最小的一个，将其放在序列开头，此时其便为已排序序列（只有一个元素） 从剩余为排序序列中，选择最小的一个，将其放在已排序序列的末尾 重复 2 过程，直到所有的元素都在已排序序列中 算法时间复杂度为O(n^2). 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}//利用宏定义来定义交换过程，简化代码void selectSort(int a[],int n);int main(){ int i,n; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); selectSort(num,n); for (i =0;i&lt;n;i++) printf("%d ",num[i]);}void selectSort(int a[],int n){ int i =0,j =0; int min = 0; for ( i =0 ;i&lt;n;i++){ min = i;//将最小值标记为i for (j = i+1;j&lt;n;j++) if(a[j]&lt;a [min])//在i后寻找最小值 min = j; SWAP(a[i],a[min]);//交换i与最小值 }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言插入排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[插入排序：插入排序算法就如同它的名字，依次在有序数组中插入待排数据，直到所有的元素都已排好序，其基本思路如下： 将第一个元素看成有序数组的首位，其余元素看成待排数据 将第二个元素与第一个元素比较，如果比第一个元素小，则第一个元素后移，然后将第二个元素放在因为后移空出的位置上，此时有序数组中有两个元素 依次重复该过程，将第i个数据与前1···i-1个有序数据比较，如果比其小，则元素后移，直到遇到一个不小于改元素的值，然后将该元素放在空出的位置上插入排序的时间复杂度为O(n^2)，不过，在数据量很小的时候（一般不超过100）,插入排序有着十分迅速的运行速率。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define SWAP(a,b) {int t = a;a =b;b =t;}void insertSort(int a[],int n);int main(){ int n,i; scanf("%d",&amp;n); int num[n]; for (i =0 ;i&lt;n;i++) scanf("%d",&amp;num[i]); insertSort(num,n); for (i =0 ;i&lt;n;i++) printf("%d ",num[i] ); return 0;}void insertSort(int a[],int n){ int i,j,flag; for (i = 0;i&lt;n;i++){ flag = a[i]; for (j =i-1;j&gt;=0;j--){ if(flag&lt;a[j]){ SWAP(a[j], a[j+1]); } else break; } }} 程序输入：1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言归并排序]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[归并排序：归并排序采用了分治的思想，在排好n个数之前，先将前n/2个数和后n/2的数排好，利用递归以此类推，然后将已排好序的两个n/2数组合并为一个长度为n的有序数组。 该算法需要一个作为中间传递已排好序数值的数组 归并排序时间复杂度为O(nlogn)，空间复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#define N 10000int k[N];void merge(int a[],int left,int right){ if(left == right)//递归的终止条件，当left==right时，只有一个元素，此时已是默认排好序的了 return ; int mid = (left+right)/2;//二分 merge(a,left,mid);//排序前半部分 merge(a,mid+1,right);//排序后半部分 int i = left,j =mid+1,p= left;//合并已经排好序的数组 while(i&lt;=mid&amp;&amp;j&lt;=right){ if(a[i]&lt;a[j]) k[p++] = a[i++]; else k[p++] = a[j++]; } while(i&lt;=mid)//如果有数组没有全部合并完，则直接放在合并数组后面 k[p++] = a[i++]; while(j&lt;=right) k[p++] = a[j++]; for (i = left;i&lt;=right;i++)//将k[]返回a[]数组中 a[i] = k[i];}int main(){ int n; scanf("%d",&amp;n); int a[n]; for (int i = 0;i&lt;n;i++) scanf("%d",&amp;a[i]); merge(a,0,n-1); for (int i = 0;i&lt;n;i++) printf("%d ",a[i]); return 0;} 程序输入： 1291 5 6 8 4 3 2 9 15 程序输出：11 2 3 4 5 6 8 9 15]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的常用命令操作]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[刚使用hexo时，对于自己如何去部署自己的blog还不太了解，本篇文章做一个小记。注意：执行代码要先在终端中进入存放hexo的文件夹 方式 :$ cd 文件夹名1$ hexo clean 清除缓存文件和已生成的静态文件 1$ hexo new post "the article's title 建立一个新的文件,文件名为“ the article’s title”，此时文件已经建立 好了，接下来就是找到该文件写下自己的blog，hexo的文件符合markdown语法。1$ hexo generate 生成静态文件，可以简写为$ hexo g1$ hexo deploy 部署网站，可以简写为$ hexo d 上面这两条命令可以合并在一起，记为$ hexo g -d 或者$hexo d -g1$ hexo server 启动服务器，可以简写为$ hexo s.默认情况下，访问网址为：http://localhost:4000/. 通常部署blog只需要三步： 使用 $hexo new post "title name" 建立新的文件 使用 markdown语法写自己的blog 使用$hexo g -d部署blog接下来打开网址就可以看到自己的blog已经部署好了]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>部署</tag>
      </tags>
  </entry>
</search>
