<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eternal_zttz</title>
  
  <subtitle>努力，为了赢得选择</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://eternalzttz.com/"/>
  <updated>2018-09-21T11:22:23.000Z</updated>
  <id>http://eternalzttz.com/</id>
  
  <author>
    <name>Eternal_zttz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dijkstra算法堆优化</title>
    <link href="http://eternalzttz.com/2018/09/21/Dijkstra%E7%AE%97%E6%B3%95%E5%A0%86%E4%BC%98%E5%8C%96/"/>
    <id>http://eternalzttz.com/2018/09/21/Dijkstra算法堆优化/</id>
    <published>2018-09-21T03:58:14.000Z</published>
    <updated>2018-09-21T11:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用堆来优化普通的Dijkstra算法，能达到更快的效果。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 9999999999999</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,nxt;</span><br><span class="line">&#125;edge;</span><br><span class="line">edge e[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt] = &#123;u,v,w,head[u]&#125;;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line">ll dis[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll u,d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp;rhs)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node flag = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        ll u  = flag.u,d = flag.d;</span><br><span class="line">        <span class="keyword">if</span>(d!=dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v] = dis[u]+w;</span><br><span class="line">                q.push((node)&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d "</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            addedge(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] == INF) <span class="built_in">printf</span>(<span class="string">"-1 "</span>);</span><br><span class="line">            <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"%lld "</span>,dis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用堆来优化普通的Dijkstra算法，能达到更快的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法记录最短路径</title>
    <link href="http://eternalzttz.com/2018/09/20/Dijkstra%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://eternalzttz.com/2018/09/20/Dijkstra算法记录最短路径/</id>
    <published>2018-09-20T04:32:46.000Z</published>
    <updated>2018-09-21T06:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>用dijkstra算法来记录最短路径方法，用一个数组path[]记录前驱顶点，找到最短路后，从终点倒向追踪，直到找到起点为止。这里可以利用栈来记录路径倒推的过程.</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,t1,t2,t3;;</span><br><span class="line"><span class="keyword">int</span> dis[N],tim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> e[N][N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = e[s][i];</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        pre[i] = dis[i]!=INF&amp;&amp;i!= s? s:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> u =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[u][v]&lt;INF)&#123;</span><br><span class="line">              <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v])&#123;</span><br><span class="line">                 dis[v] = dis[u] +e[u][v];</span><br><span class="line">                  pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">00</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            e[i][j] = i==j? <span class="number">0</span>:INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        <span class="keyword">if</span>(e[t1][t2]&gt;t3)</span><br><span class="line">            e[t1][t2] = t3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start ,end;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start,&amp;end))&#123;</span><br><span class="line">         s = start;</span><br><span class="line">         dijkstra();</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d到%d的最短路径是：%d\n"</span>,start,end,start);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">            path.push(end);</span><br><span class="line">            <span class="keyword">int</span> now = pre[end];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                path.push(now);</span><br><span class="line">                <span class="keyword">if</span>(now == start)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                now = pre[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d到%d的最短路线是：%d"</span>,start,end,start);</span><br><span class="line">            path.pop();</span><br><span class="line">            <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"--&gt;%d"</span>,path.top());</span><br><span class="line">                path.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,dis[end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span> <span class="number">12</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从<span class="number">4</span>到<span class="number">3</span>的最短路线是：<span class="number">4</span>--&gt;<span class="number">1</span>--&gt;<span class="number">2</span>--&gt;<span class="number">3</span></span><br><span class="line">最短路径：<span class="number">10</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用dijkstra算法来记录最短路径方法，用一个数组path[]记录前驱顶点，找到最短路后，从终点倒向追踪，直到找到起点为止。这里可以利用栈来记录路径倒推的过程.&lt;/p&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法求解最短路问题</title>
    <link href="http://eternalzttz.com/2018/09/20/Dijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://eternalzttz.com/2018/09/20/Dijkstra算法求解最短路问题/</id>
    <published>2018-09-20T01:15:32.000Z</published>
    <updated>2018-09-21T11:20:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra算法思路：Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。<br><a id="more"></a><br>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，<br>然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。<br>然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,t1,t2,t3;;</span><br><span class="line"><span class="keyword">int</span> dis[N],tim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> e[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] = e[s][i];</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> u =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;min)&#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[u][v]&lt;INF)&#123;</span><br><span class="line">              <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+e[u][v])&#123;</span><br><span class="line">                 dis[v] = dis[u] +e[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">00</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            e[i][j] = i==j? <span class="number">0</span>:INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        <span class="keyword">if</span>(e[t1][t2]&gt;t3)</span><br><span class="line">            e[t1][t2] = t3;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dijkstra算法思路：Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>SPFA算法记录最短路径</title>
    <link href="http://eternalzttz.com/2018/09/19/SPFA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://eternalzttz.com/2018/09/19/SPFA算法记录最短路径/</id>
    <published>2018-09-19T11:35:47.000Z</published>
    <updated>2018-09-21T06:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>路径记录方法：用path[]数组依次记录前驱节点，当找到最短路后，由终点倒推，直到找到起点，可以利用一个栈来维护此过程。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 999999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[N],len[N],pre[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(node edge[],<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[cnt] = &#123;u,v,w,head[u]&#125;;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q,node edge[])</span></span>&#123;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        len[i] = INF;</span><br><span class="line">    len[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i&gt;<span class="number">0</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(len[v]&gt; len[u]+w)&#123;</span><br><span class="line">                len[v] =len[u]+w;</span><br><span class="line">                pre[v] = u;<span class="comment">//记录v的前驱节点为u</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] =<span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    node edge[m+<span class="number">1</span>];</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(len,<span class="number">0</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(edge,u,v,w);</span><br><span class="line">        <span class="comment">//add(edge,v,u,w);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start,end;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start,&amp;end))&#123;</span><br><span class="line">        s = start;</span><br><span class="line">        SPFA(q, edge);</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d 到%d的最短路线：%d\n"</span>,start,end,start);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d"</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">            path.push(end);</span><br><span class="line">            <span class="keyword">int</span> now = pre[end];<span class="comment">//now 为end的前驱节点，即倒数第二个节点</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                path.push(now);</span><br><span class="line">                <span class="keyword">if</span>(now == start)<span class="comment">//找到起点，退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                now = pre[now];<span class="comment">//依次寻找上一个节点的前驱节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d到%d的最短路线：%d"</span>,start,end,start);</span><br><span class="line">            path.pop();</span><br><span class="line">            <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"--&gt;%d"</span>,path.top());</span><br><span class="line">                path.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,len[end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路径记录方法：用path[]数组依次记录前驱节点，当找到最短路后，由终点倒推，直到找到起点，可以利用一个栈来维护此过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>SPFA算法求解最短路问题</title>
    <link href="http://eternalzttz.com/2018/09/19/SPFA%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://eternalzttz.com/2018/09/19/SPFA算法求解最短路问题/</id>
    <published>2018-09-19T10:24:14.000Z</published>
    <updated>2018-09-21T06:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>SPFA算法实现方法：建立一个队列，初始时队列中只有起始点，用一个数组记录起始点A到其他所有点之间的距离（初始时自身为0，其余为INF),然后利用该点A对与该点直接相通的点Bi进行松弛操作，如果操作成功，而被Bi未在队列中，那么Bi入队。A出队，然后对队列中的下一个元素做相同的操作，直到队列为空，此时数组中的值便是起始点与其余点之间的最短路径。<br>SPFA算法可判断是否存在负权环路，判断方法是检查是否存在一个点进入队列N次。<br>算法复杂度为O(KE).<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[N],len[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(node edge[],<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     edge[cnt].u =u;</span></span><br><span class="line"><span class="comment">     edge[cnt].v = v;</span></span><br><span class="line"><span class="comment">     edge[cnt].w = w;</span></span><br><span class="line"><span class="comment">     edge[cnt].next = head[u];</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    edge[cnt]=&#123;u,v,w,head[u]&#125;;<span class="comment">//这一句相当于上面四句</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q,node edge[])</span></span>&#123;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        len[i] = INF;</span><br><span class="line">    len[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i&gt;<span class="number">0</span>;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(len[v]&gt; len[u]+w)&#123;</span><br><span class="line">                len[v] =len[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] =<span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s))&#123;<span class="comment">//n为顶点数，m为边数，s为起始点</span></span><br><span class="line">        node edge[m+<span class="number">1</span>];</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(len,<span class="number">0</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(edge,u,v,w);</span><br><span class="line">            <span class="comment">//add(edge,v,u,w);如果是无向图，则加上这一句，注意加上后edge数组的范围应扩大一倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        SPFA(q, edge);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,len[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SPFA算法实现方法：建立一个队列，初始时队列中只有起始点，用一个数组记录起始点A到其他所有点之间的距离（初始时自身为0，其余为INF),然后利用该点A对与该点直接相通的点Bi进行松弛操作，如果操作成功，而被Bi未在队列中，那么Bi入队。A出队，然后对队列中的下一个元素做相同的操作，直到队列为空，此时数组中的值便是起始点与其余点之间的最短路径。&lt;br&gt;SPFA算法可判断是否存在负权环路，判断方法是检查是否存在一个点进入队列N次。&lt;br&gt;算法复杂度为O(KE).&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Floyd算法记录路径</title>
    <link href="http://eternalzttz.com/2018/09/19/Floyd%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84/"/>
    <id>http://eternalzttz.com/2018/09/19/Floyd算法记录路径/</id>
    <published>2018-09-19T01:18:56.000Z</published>
    <updated>2018-09-21T06:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于Floyd算法记录路径的方法一般有两种：一是用path[i][j]记录i的后继节点，二是用path[i][j]记录j的前驱节点。<br><a id="more"></a><br>第一种方法：利用path[i][j]记录i的后继节点。<br>路径记录关键代码：<br>1: 初始化：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path[<span class="string">i</span>][<span class="symbol">j</span>] = j;</span><br></pre></td></tr></table></figure></p><p>2:路径转移记录：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path[<span class="string">i</span>][<span class="symbol">j</span>] = path[<span class="string">i</span>][<span class="symbol">k</span>];</span><br></pre></td></tr></table></figure></p><p>完整代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000001</span></span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,t1,t2,t3;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化e,path数组</span></span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                e[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i][j] = INF;</span><br><span class="line">            path[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        <span class="keyword">if</span>(e[t1][t2]&gt;t3)</span><br><span class="line">            e[t1][t2] = t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//floyd算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])&#123;</span><br><span class="line">                    e[i][j]=e[i][k]+e[k][j];</span><br><span class="line">                    path[i][j] = path[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    Floyd();</span><br><span class="line">    <span class="keyword">int</span> start,end;</span><br><span class="line">    <span class="comment">//得出从start 到end 的路径</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start,&amp;end))&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d到%d的最优路线 : %d\n"</span>,start,end,start);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从%d到%d的最短路线：%d"</span>,start,end,start);</span><br><span class="line">            <span class="keyword">int</span> now= path[start][end];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"--&gt;%d"</span>,now);</span><br><span class="line">                <span class="keyword">if</span>(now == end)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                now = path[now][end];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,e[start][end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>第二种方法：利用path[i][j]记录j的前驱节点,这个方法需要利用stack来输出路径<br>路径记录关键代码：<br>1:初始化：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="string">i</span>][<span class="symbol">j</span>] = i;</span><br></pre></td></tr></table></figure></p><p>2:路径转移记录：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="string">i</span>][<span class="symbol">j</span>] = pre[<span class="string">k</span>][<span class="symbol">j</span>];</span><br></pre></td></tr></table></figure></p><p>完整代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,t1,t2,t3;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            e[i][j] = i==j? <span class="number">0</span>:INF;</span><br><span class="line">            pre[i][j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        <span class="keyword">if</span>(e[t1][t2]&gt;t3)</span><br><span class="line">            e[t1][t2] = t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k =<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])&#123;</span><br><span class="line">                    e[i][j] = e[i][k]+e[k][j];</span><br><span class="line">                    pre[i][j] = pre[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    Floyd();</span><br><span class="line">    <span class="keyword">int</span> start,end;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;start,&amp;end))&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从 %d 到 %d 的最短路线：%d\n"</span>,start,end,start);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径:%d\n"</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> now = pre[start][end];</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line">            path.push(end);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                path.push(now);</span><br><span class="line">                <span class="keyword">if</span>(now == start)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                now = pre[start][now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"从 %d 到 %d 的最短路线：%d"</span>,start,end,start);</span><br><span class="line">            path.pop();</span><br><span class="line">            <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"--&gt;%d"</span>,path.top());</span><br><span class="line">                path.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"最短路径：%d\n"</span>,e[start][end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Floyd算法记录路径的方法一般有两种：一是用path[i][j]记录i的后继节点，二是用path[i][j]记录j的前驱节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>floyd最短路算法</title>
    <link href="http://eternalzttz.com/2018/09/18/floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://eternalzttz.com/2018/09/18/floyd最短路算法/</id>
    <published>2018-09-18T13:27:05.000Z</published>
    <updated>2018-09-21T06:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Floyd算法是一种动态规划算法，适用于多源最短路径，相对于Dijkstra算法和SPFA算法，其算法复杂度较高，时间复杂度为O(n^3),但其理解较为容易，且代码简单。<br>其基本思想便是对点松弛，在任意 i,j 顶点中，看是否存在顶底k,使得i -&gt; k -&gt; j 的距离小于i -&gt; j的距离，如果存在，则对该两点进行松弛操作。<br><a id="more"></a><br>核心代码：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int k = 1;k<span class="xml"><span class="tag">&lt;<span class="name">=n;k++)&#123;</span></span></span></span><br><span class="line"><span class="xml">        for (int i = 1;i<span class="tag">&lt;<span class="name">=n;i++)&#123;</span></span></span></span><br><span class="line"><span class="xml">            for (int j = 1;j<span class="tag">&lt;<span class="name">=n;j++)&#123;</span></span></span></span><br><span class="line"><span class="xml">                if(e[i][j]&gt;</span>e[<span class="string">i</span>][<span class="symbol">k</span>]+e[<span class="string">k</span>][<span class="symbol">j</span>])</span><br><span class="line"><span class="code">                    e[i][j] = e[i][k]+e[k][j];</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>完整代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span>  e[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,t1,t2,t3;</span><br><span class="line">    <span class="keyword">int</span>  inf = <span class="number">9999999</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span> ;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                e[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line"><span class="comment">//这里if主要是为了在存在多条从t1到t2的路径时，记录最短的一条</span></span><br><span class="line">        <span class="keyword">if</span>(e[t1][t2]&gt;t3)    </span><br><span class="line">            e[t1][t2] = t3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">                    e[i][j] = e[i][k]+e[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,e[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>测试数据：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span> <span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">9 </span><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">6 </span><span class="number">8</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">5 </span><span class="number">7</span> <span class="number">10</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Floyd算法是一种动态规划算法，适用于多源最短路径，相对于Dijkstra算法和SPFA算法，其算法复杂度较高，时间复杂度为O(n^3),但其理解较为容易，且代码简单。&lt;br&gt;其基本思想便是对点松弛，在任意 i,j 顶点中，看是否存在顶底k,使得i -&amp;gt; k -&amp;gt; j 的距离小于i -&amp;gt; j的距离，如果存在，则对该两点进行松弛操作。&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="算法" scheme="http://eternalzttz.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://eternalzttz.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>C语言快速排序</title>
    <link href="http://eternalzttz.com/2018/09/17/C%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/09/17/C语言快速排序/</id>
    <published>2018-09-17T14:28:33.000Z</published>
    <updated>2018-09-21T11:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序；基本思路：</p><ol><li><p>从当前参加排序的元素中任选一个元素作为分界元素，与当前参加排序的那些元素进行比较.</p></li><li><p>凡是小于分界元素的元素都移到分界元素的前面,凡是大于分界元的元素都移到分界元素的后面。</p></li><li><p>分界元素将当前参加排序的元素分成前后两部分,而分界元素处在排序的最终位置。</p></li><li><p>然后，分别对这两部分中大小大于1的部分重复上述过程直到排序结束<br>时间复杂度为：O(nlogn)</p></li></ol><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123;int t = a;a =b;b =t;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> key = a[left];</span><br><span class="line">    <span class="keyword">int</span> i = left,j = right;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;=key)</span><br><span class="line">            j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=key)</span><br><span class="line">            i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] =key;</span><br><span class="line">    quicksort(a, left, i<span class="number">-1</span>);</span><br><span class="line">    quicksort(a, i+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> num[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">        quicksort(num,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序；基本思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从当前参加排序的元素中任选一个元素作为分界元素，与当前参加排序的那些元素进行比较.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;凡是小于分界元素的元素都移到分界元素的前面,凡是大于分界元的元素都移到分界元素的后面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分界元素将当前参加排序的元素分成前后两部分,而分界元素处在排序的最终位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后，分别对这两部分中大小大于1的部分重复上述过程直到排序结束&lt;br&gt;时间复杂度为：O(nlogn)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言堆排序</title>
    <link href="http://eternalzttz.com/2018/09/17/C%E8%AF%AD%E8%A8%80%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/09/17/C语言堆排序/</id>
    <published>2018-09-17T14:28:23.000Z</published>
    <updated>2018-09-21T10:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序：堆排序可以看成优化版的选择排序</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了<br>其算法时间复杂度为O(nlogn)</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123;int t = a;a = b;b = t;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    heapSort(num,n);</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,temp;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n&amp;&amp;a[j]&lt;a[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;a[j])&#123;</span><br><span class="line">            a[(j<span class="number">-1</span>)/<span class="number">2</span>] = a[j];</span><br><span class="line">            j = <span class="number">2</span>*j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[(j<span class="number">-1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        adjust(a,i,n);</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        SWAP(a[<span class="number">0</span>],a[i]);</span><br><span class="line">        adjust(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序：堆排序可以看成优化版的选择排序&lt;/p&gt;
&lt;p&gt;堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了&lt;br&gt;其算法时间复杂度为O(nlogn)&lt;/p&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言冒泡排序</title>
    <link href="http://eternalzttz.com/2018/09/17/C%E8%AF%AD%E8%A8%80%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/09/17/C语言冒泡排序/</id>
    <published>2018-09-17T14:27:59.000Z</published>
    <updated>2018-09-21T07:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序是一种简单的排序算法 ，其基本思路如下：</p><ol><li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>其算法时间复杂度为O(n^2).<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123;int t = a;a =b;b =t;&#125;<span class="comment">//宏定义交换过程</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    bubbleSort(num,n);</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                SWAP(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果某一趟排序没有进行交换，说明排序已经结束，可以略微提高排序的效率</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冒泡排序是一种简单的排序算法 ，其基本思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;br&gt;其算法时间复杂度为O(n^2).
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言选择排序</title>
    <link href="http://eternalzttz.com/2018/09/17/C%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/09/17/C语言选择排序/</id>
    <published>2018-09-17T14:27:50.000Z</published>
    <updated>2018-09-21T07:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>选择排序是基本排序算法之一，其基本思路为：</p><ol><li>初始时选择整个序列中最小的一个，将其放在序列开头，此时其便为已排序序列（只有一个元素）</li><li>从剩余为排序序列中，选择最小的一个，将其放在已排序序列的末尾</li><li>重复 2 过程，直到所有的元素都在已排序序列中</li></ol><p>算法时间复杂度为O(n^2).<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123;int t = a;a =b;b =t;&#125;<span class="comment">//利用宏定义来定义交换过程，简化代码</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    selectSort(num,n);</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>,j =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i =<span class="number">0</span> ;i&lt;n;i++)&#123;</span><br><span class="line">        min = i;<span class="comment">//将最小值标记为i</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a [min])<span class="comment">//在i后寻找最小值</span></span><br><span class="line">                min = j;</span><br><span class="line">        SWAP(a[i],a[min]);<span class="comment">//交换i与最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择排序是基本排序算法之一，其基本思路为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时选择整个序列中最小的一个，将其放在序列开头，此时其便为已排序序列（只有一个元素）&lt;/li&gt;
&lt;li&gt;从剩余为排序序列中，选择最小的一个，将其放在已排序序列的末尾&lt;/li&gt;
&lt;li&gt;重复 2 过程，直到所有的元素都在已排序序列中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法时间复杂度为O(n^2).&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序算法" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言插入排序</title>
    <link href="http://eternalzttz.com/2018/09/17/C%E8%AF%AD%E8%A8%80%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/09/17/C语言插入排序/</id>
    <published>2018-09-17T14:26:01.000Z</published>
    <updated>2018-09-21T07:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>插入排序：插入排序算法就如同它的名字，依次在有序数组中插入待排数据，直到所有的元素都已排好序，其基本思路如下：</p><ol><li>将第一个元素看成有序数组的首位，其余元素看成待排数据</li><li>将第二个元素与第一个元素比较，如果比第一个元素小，则第一个元素后移，然后将第二个元素放在因为后移空出的位置上，此时有序数组中有两个元素</li><li>依次重复该过程，将第i个数据与前1···i-1个有序数据比较，如果比其小，则元素后移，直到遇到一个不小于改元素的值，然后将该元素放在空出的位置上<br>插入排序的时间复杂度为O(n^2)，不过，在数据量很小的时候（一般不超过100）,插入排序有着十分迅速的运行速率。</li></ol><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) &#123;int t = a;a =b;b =t;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    insertSort(num,n);</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span> ;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,flag;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        flag = a[i];</span><br><span class="line">        <span class="keyword">for</span> (j =i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag&lt;a[j])&#123;</span><br><span class="line">                SWAP(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输入：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;插入排序：插入排序算法就如同它的名字，依次在有序数组中插入待排数据，直到所有的元素都已排好序，其基本思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将第一个元素看成有序数组的首位，其余元素看成待排数据&lt;/li&gt;
&lt;li&gt;将第二个元素与第一个元素比较，如果比第一个元素小，则第一个元素后移，然后将第二个元素放在因为后移空出的位置上，此时有序数组中有两个元素&lt;/li&gt;
&lt;li&gt;依次重复该过程，将第i个数据与前1···i-1个有序数据比较，如果比其小，则元素后移，直到遇到一个不小于改元素的值，然后将该元素放在空出的位置上&lt;br&gt;插入排序的时间复杂度为O(n^2)，不过，在数据量很小的时候（一般不超过100）,插入排序有着十分迅速的运行速率。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言归并排序</title>
    <link href="http://eternalzttz.com/2018/05/23/C%E8%AF%AD%E8%A8%80%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://eternalzttz.com/2018/05/23/C语言归并排序/</id>
    <published>2018-05-23T03:26:33.000Z</published>
    <updated>2018-09-21T10:56:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序：归并排序采用了分治的思想，在排好n个数之前，先将前n/2个数和后n/2的数排好，利用递归以此类推，然后将已排好序的两个n/2数组合并为一个长度为n的有序数组。</p><p>该算法需要一个作为中间传递已排好序数值的数组</p><p>归并排序时间复杂度为O(nlogn)，空间复杂度为O(n)</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000</span></span><br><span class="line"><span class="keyword">int</span> k[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)<span class="comment">//递归的终止条件，当left==right时，只有一个元素，此时已是默认排好序的了</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">    merge(a,left,mid);<span class="comment">//排序前半部分</span></span><br><span class="line">    merge(a,mid+<span class="number">1</span>,right);<span class="comment">//排序后半部分</span></span><br><span class="line">    <span class="keyword">int</span> i = left,j =mid+<span class="number">1</span>,p= left;<span class="comment">//合并已经排好序的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">            k[p++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k[p++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)<span class="comment">//如果有数组没有全部合并完，则直接放在合并数组后面</span></span><br><span class="line">        k[p++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        k[p++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = left;i&lt;=right;i++)<span class="comment">//将k[]返回a[]数组中</span></span><br><span class="line">        a[i] = k[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    merge(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>程序输入：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p>程序输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span></span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;归并排序：归并排序采用了分治的思想，在排好n个数之前，先将前n/2个数和后n/2的数排好，利用递归以此类推，然后将已排好序的两个n/2数组合并为一个长度为n的有序数组。&lt;/p&gt;
&lt;p&gt;该算法需要一个作为中间传递已排好序数值的数组&lt;/p&gt;
&lt;p&gt;归并排序时间复杂度为O(nlogn)，空间复杂度为O(n)&lt;/p&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://eternalzttz.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="C" scheme="http://eternalzttz.com/tags/C/"/>
    
      <category term="排序" scheme="http://eternalzttz.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于hexo的常用命令操作</title>
    <link href="http://eternalzttz.com/2018/04/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://eternalzttz.com/2018/04/27/我的第一篇博客/</id>
    <published>2018-04-27T13:35:57.000Z</published>
    <updated>2018-09-21T04:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚使用hexo时，对于自己如何去部署自己的blog还不太了解，本篇文章做一个小记。<br><strong><em>注意：执行代码要先在终端中进入存放hexo的文件夹   方式  :<code>$ cd 文件夹名</code></em></strong><br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br></pre></td></tr></table></figure></p><p>清除缓存文件和已生成的静态文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> post <span class="comment">"the article's title</span></span><br></pre></td></tr></table></figure><p>建立一个新的文件,文件名为“ the article’s title”，此时文件已经建立 好了，接下来就是找到该文件写下自己的blog，hexo的文件符合markdown语法。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure></p><p>生成静态文件，可以简写为<code>$ hexo g</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br></pre></td></tr></table></figure></p><p>部署网站，可以简写为<code>$ hexo d</code></p><p>上面这两条命令可以合并在一起，记为<code>$ hexo g -d</code> 或者<code>$hexo d -g</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure></p><p>启动服务器，可以简写为<code>$ hexo s</code>.默认情况下，访问网址为：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>.</p><hr><p>通常部署blog只需要三步：</p><ol><li>使用 <code>$hexo new post &quot;title name&quot;</code> 建立新的文件</li><li>使用 markdown语法写自己的blog</li><li>使用<code>$hexo g -d</code>部署blog<br>接下来打开网址就可以看到自己的blog已经部署好了</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚使用hexo时，对于自己如何去部署自己的blog还不太了解，本篇文章做一个小记。&lt;br&gt;&lt;strong&gt;&lt;em&gt;注意：执行代码要先在终端中进入存放hexo的文件夹   方式  :&lt;code&gt;$ cd 文件夹名&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://eternalzttz.com/tags/hexo/"/>
    
      <category term="部署" scheme="http://eternalzttz.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
